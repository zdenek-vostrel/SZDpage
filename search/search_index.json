{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SZD","text":"<p>Kdyby se tahle str\u00e1nka l\u00edbila, m\u016f\u017eeme ji ud\u011blat i pro ty p\u0159epsan\u00e9 k\u00f3dy v Pythonu. Fakt jednodu\u0161e se to upravuje ve form\u00e1tu markdown, co\u017e je n\u011bco s podobnou filozofi\u00ed jako LaTeX (akor\u00e1t to je tro\u0161ku jednodu\u0161\u0161\u00ed a slab\u0161\u00ed). Kdybys cht\u011bl vid\u011bt hotovou str\u00e1nku, tak tady je dokumentace, co jsem d\u011blal v CERNu. To, co re\u00e1ln\u011b jsem napsal j\u00e1, je ve slo\u017ece <code>./docs</code>, zbytek se generuje. Vypad\u00e1 v tom dob\u0159e popis k\u00f3du, daj\u00ed se tu ps\u00e1t rovnice LaTeX stylem</p> \\[ f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi} } e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2} \\] <p>Popis instalace a setupu geantu je tady.</p>"},{"location":"geant4.html","title":"Geant4 instalace&amp;setup","text":""},{"location":"geant4.html#setup-bez-vlastni-lokalni-instalace","title":"Setup bez vlastn\u00ed lok\u00e1ln\u00ed instalace","text":""},{"location":"geant4.html#c","title":"C++","text":"<p>Spr\u00e1vn\u00e9 prost\u0159ed\u00ed se nastav\u00ed pomoc\u00ed </p> <pre><code>. /data2/vyuka/szd/SZD2-codes/setup_ROOTandPython3.sh\n</code></pre> <p>Projekt <code>test_geant.cpp</code> pak lze kompilovat p\u0159\u00edkazem</p> <pre><code>gcc test_geant.cpp `geant4-config \u2014libs \u2014cflags` -lstdc++\n</code></pre>"},{"location":"geant4.html#python","title":"Python","text":"<p>Prost\u0159ed\u00ed se nastav\u00ed pomoc\u00ed </p> <pre><code>. /home/vostrzd1/SZD2/setup_GeantPython.sh\n</code></pre> Info <p>Tohle pak m\u016f\u017eeme p\u0159ed\u011blat na tvoje, a\u017e si to nainstaluje\u0161.</p> <p>Spr\u00e1vnost nastaven\u00ed si lze ov\u011b\u0159it zapnut\u00edm pythonu (p\u0159\u00edkaz <code>python</code>) a n\u00e1sledn\u011b uvnit\u0159 Pythonu p\u0159\u00edkazem </p> <pre><code>import geant4_pybind\n</code></pre> <p>Pokud se nevyp\u00ed\u0161e \u017e\u00e1dn\u00fd error, setup prob\u011bhl \u00fasp\u011b\u0161n\u011b. </p> <p></p>"},{"location":"geant4.html#instalace-pro-python","title":"Instalace pro Python","text":"<p>Pro instalaci pou\u017eijeme Anacondu, co\u017e je package a environment manager pro Python. Jedn\u00e1 se o jednu z ofici\u00e1ln\u011b doporu\u010den\u00fdch instalac\u00ed Geant4. P\u0159\u00ed lok\u00e1ln\u00ed instalaci t\u00edmto zp\u016fsobem p\u016fjde kompilovat i C++ verze Geantu.</p> <p>P\u0159\u00edprava Geant4 pro Python je pops\u00e1na v n\u00e1sleduj\u00edc\u00edch kroc\u00edch.</p> <p>Note</p> <p>Pro instalaci je dobr\u00e9 m\u00edt otev\u0159en\u00fd nov\u00fd termin\u00e1l, ve kter\u00e9m nejsou setupovan\u00e1 \u017e\u00e1dn\u00e1 prost\u0159ed\u00ed.</p>"},{"location":"geant4.html#1-instalace-anacondy","title":"1. Instalace Anacondy","text":"<p>V prvn\u00edm kroku je pot\u0159eba nainstalovat Anacondu z ofici\u00e1ln\u00edch str\u00e1nek. Nejjednodu\u0161\u0161\u00ed je instalace z p\u0159\u00edkazov\u00e9ho \u0159\u00e1dku. </p> <p>Warning</p> <p>P\u0159i instalaci z p\u0159\u00edkazov\u00e9ho \u0159\u00e1dku je pot\u0159eba spustit oba sety p\u0159\u00edkaz\u016f, tedy i ten, kter\u00fd obsahuje <code>init</code>.  </p> <p>Anaconda automaticky updatuje v\u00e1\u0161 <code>~/.bashrc</code>, co\u017e znamen\u00e1, \u017ee se Anaconda inicializuje p\u0159i ka\u017ed\u00e9m nov\u00e9m otev\u0159en\u00ed termin\u00e1lu. Pokud toto chov\u00e1n\u00ed nechcete, je pot\u0159eba setup Anacondy z <code>~/.bashrc</code> vymazat a p\u0159esunout do samostatn\u00e9ho setup souboru, kter\u00fd budete pou\u017e\u00edvat pro setup Anacondy. Zmi\u0148ovan\u00fd \u00fasek je n\u00e1sleduj\u00edc\u00ed (se zm\u011bnou cesty na tu va\u0161i):</p> ~/.bashrc<pre><code>...\n# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;\n# !! Contents within this block are managed by 'conda init' !!\n__conda_setup=\"$('/home/vostrzd1/miniconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)\"\nif [ $? -eq 0 ]; then\n    eval \"$__conda_setup\"\nelse\n    if [ -f \"/home/vostrzd1/miniconda3/etc/profile.d/conda.sh\" ]; then\n        . \"/home/vostrzd1/miniconda3/etc/profile.d/conda.sh\"\n    else\n        export PATH=\"/home/vostrzd1/miniconda3/bin:$PATH\"\n    fi\nfi\nunset __conda_setup\n# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;\n...\n</code></pre> <p>Pro ov\u011b\u0159en\u00ed, \u017ee v\u0161e funguje, jak m\u00e1, je pot\u0159eba zav\u0159\u00edt a znovu otev\u0159\u00edt termin\u00e1l. Pokud jste setup ponechali v <code>~/.bashrc</code>, m\u011blo by se vedle va\u0161eho jm\u00e9no objevit <code>(base)</code>, co\u017e zn\u00e1zor\u0148uje z\u00e1kladn\u00ed Anaconda prost\u0159ed\u00ed. Pokud jste setup p\u0159esunuli do jin\u00e9ho souboru, je pot\u0159eba tento skript nejd\u0159\u00edve spustit. </p> <p></p>"},{"location":"geant4.html#2-instalace-geant4-pomoci-anacondy","title":"2. Instalace Geant4 pomoc\u00ed Anacondy","text":"<p>Instalace Geant4 pomoc\u00ed Anacondy je pops\u00e1na v ofici\u00e1ln\u00edm instala\u010dn\u00edm n\u00e1vodu Geant4. Pokud byla Anaconda spr\u00e1vn\u011b nainstalov\u00e1na, sta\u010d\u00ed spustit n\u00e1sleduj\u00edc\u00ed p\u0159\u00edkazy</p> <pre><code>conda create -c conda-forge --name geant4 geant4 #(1)!\nconda activate geant4 #(2)!\n</code></pre> <ol> <li>Vytvo\u0159\u00ed prost\u0159ed\u00ed s n\u00e1zvem <code>geant4</code> na nainstaluje do n\u011bj Geant4.</li> <li>Aktivuje prost\u0159ed\u00ed s n\u00e1zvem <code>geant4</code>.</li> </ol> <p>Inicializace prost\u0159ed\u00ed pomoc\u00ed druh\u00e9ho p\u0159\u00edkazu je nutn\u00e1 v\u017edy po otev\u0159en\u00ed nov\u00e9ho termin\u00e1lu. </p> <p>Po aktivace se zm\u011bn\u00ed text v z\u00e1vorce vedle va\u0161eho jm\u00e9na v termin\u00e1lu z <code>(base)</code> na <code>(geant4)</code>: </p>"},{"location":"geant4.html#3-instalace-knihovny-geant4-pro-python","title":"3. Instalace knihovny Geant4 pro python","text":"<p>Warning</p> <p>V tomto kroku mus\u00ed b\u00fdt nastaven\u00e9 prost\u0159ed\u00ed <code>geant4</code> vytvo\u0159en\u00e9 v p\u0159edchoz\u00edm kroku. Aktivace prob\u00edh\u00e1 p\u0159\u00edkazem  <pre><code>conda activate geant4\n</code></pre> Po aktivaci bude v termin\u00e1lu nalevo od va\u0161eho jm\u00e9na <code>(geant4)</code>. </p> <p>Instalace Geant4 knihovny pro Python prob\u00edh\u00e1 spu\u0161t\u011bn\u00edm n\u00e1sleduj\u00edc\u00edho p\u0159\u00edkazu</p> <pre><code>pip install geant4-pybind\n</code></pre> <p>Spr\u00e1vnost instalace si lze ov\u011b\u0159it zapnut\u00edm pythonu (p\u0159\u00edkaz <code>python</code>) a n\u00e1sledn\u011b uvnit\u0159 Pythonu p\u0159\u00edkazem </p> <pre><code>import geant4_pybind\n</code></pre> <p>Pokud se nevyp\u00ed\u0161e \u017e\u00e1dn\u00fd error, setup prob\u011bhl \u00fasp\u011b\u0161n\u011b. </p>"},{"location":"szd1/index.html","title":"SZD1","text":""},{"location":"szd2/index.html","title":"SZD2","text":""},{"location":"szd2/geant/geant4.html","title":"Geant4","text":"<p>Geant4 is a powerful, open-source simulation toolkit used to model the interaction of particles with matter. It's widely used in various fields, including:</p> <ul> <li>High-Energy Physics: Simulating particle collisions, detector responses, and data analysis.</li> <li>Nuclear Physics: Studying nuclear reactions, radiation transport, and detector simulations.</li> <li>Medical Physics: Modeling radiation therapy, dosimetry, and medical imaging.</li> <li>Space Exploration: Simulating radiation effects on spacecraft, astronauts, and electronic components.</li> <li>Materials Science: Investigating radiation damage, radiation-induced effects, and materials properties.</li> </ul> <p>Geant4 provides a comprehensive framework for simulating the transport of particles, such as electrons, photons, neutrons, and ions, through various materials and detectors. It takes into account complex physical processes, including:</p> <ul> <li>Ionization and excitation</li> <li>Bremsstrahlung and pair production</li> <li>Compton scattering and photoelectric effects</li> <li>Hadronic interactions and nuclear reactions</li> </ul> <p>The toolkit allows the user to define:</p> <ul> <li>Interaction physics</li> <li>Geometry and composition of the matter (detector)</li> <li>Particle generation</li> <li>Data readout</li> <li>Vizualisation</li> </ul> <p>Geant4 is written in C++ and provides a flexible, modular architecture, allowing users to customize and extend the toolkit to suit their specific needs. There is also a possibility to use Geant4 with Python.</p> <p>Info</p> <p>Basic understanding of the framework can be obtained by following this youtube playlist. </p>"},{"location":"szd2/geant/geant4.html#installation-setup","title":"Installation &amp; setup","text":"<p>The instruction for a local installation one needs to follow the dedicated official documentation. </p> <p>On sunrise machine, Geant4 can be set up by ... #todo</p>"},{"location":"szd2/geant/geant4.html#simulation-setup","title":"Simulation setup","text":"<p>There are three components that need to be prepared for each simulation:</p> <ul> <li> <p>Construction definition</p> <p>Definition of the geometry and material of the detector or general volume, that we want to simulate. </p> <p> More</p> </li> <li> <p>Physics list</p> <p>Definition of the actual physics that will be active during the simulation. </p> <p>This is mainly for speed purposes: for example during simulation of electrons in electromagnetic calorimeters, no hadronic processes are needed so we can turn them off and speed up the simulation.</p> <p> More</p> </li> <li> <p>Action definition</p> <p>Definition of various action performed during the simulations: generation of particles, detection of particles, tracking and stepping.</p> <p> More</p> </li> </ul> <p></p> C++Python <p>In <code>C++</code>, each part needs to be writted as a separate class, for clarity purposes with its own header and definition file. The typical file structure is therefore</p> <pre><code>mainFile.cc\nCMakeLists.txt\ninclude/\n    construction.hh\n    physicsList.hh\n    action.hh\nsrc/\n    construction.cc\n    physicsList.cc\n    action.cc\n</code></pre> <p>The structure of the main file is explained later. </p> <p>The <code>CMakeLists.txt</code> is required for proper compilation of the multiple files. For details, refer to Running the simulation.</p> <p>In <code>Python</code>, each part needs to be writtes as a separate class. However, thanks to simplicity of <code>Python</code>, it is recommanded to keep everything in one file, unless the project is very complicated. </p>"},{"location":"szd2/geant/geant4.html#main-file","title":"Main file","text":"<p>In the main file, we tell Geant what files we want to use to define the individual parts of the simulation, start the GUI and apply basic commands. </p> C++Python mainFile.cc<pre><code>#include \"iostream\"\n\n// We import the Geant stuff\n#include \"G4RunManager.hh\"\n#include \"G4UIExecutive.hh\"\n#include \"G4VisExecutive.hh\"\n#include \"G4VisManager.hh\"\n#include \"G4UImanager.hh\"\n\n// We import our header files for construction, physics list and action\n#include \"include/construction.hh\"\n#include \"include/physicsList.hh\"\n#include \"include/action.hh\"\n\nint main(int argc, char** argv){\n    // We initialise the Geant4 manager\n    auto *runManager = new G4RunManager();\n\n    // We tell Geant what construction, physics list and action to use\n    // these classes are defined in the imported header files\n    runManager-&gt;SetUserInitialization(new ConstructionDefinition());\n    runManager-&gt;SetUserInitialization(new PhysicsListDefinition());\n    runManager-&gt;SetUserInitialization(new ActionDefinition());\n\n    // We initialise the Geant4 manager\n    runManager-&gt;Initialize();\n\n    // We prepare and initialise the GUI\n    auto *ui = new G4UIExecutive(argc, argv);\n    auto *visManager = new G4VisExecutive();\n    visManager-&gt;Initialize();\n\n    // We can send commands (e.g. create particles) from \n    // the GUI or from here already using the UImanager\n    G4UImanager *UImanager =  G4UImanager::GetUIpointer();\n    // Commands are applied like this: \n    // this one tells the UI to run 10 particles\n    UImanager-&gt;ApplyCommand(\"/run/beamOn 10\");\n\n    // Finally we start the session\n    ui-&gt;SessionStart();\n\n    return 0;\n}\n</code></pre> mainFile.py<pre><code># We import Geant4\nfrom geant4_pybind import *\n\n# We either import the required classes (construction, physics list, action) \n# from separate definition files or define them here above the main funciton\n\ndef main(electronEnergy, foilWidth, fPath, nParticles):\n    # We initialise the Geant4 manager\n    runManager = G4RunManagerFactory.CreateRunManager(G4RunManagerType.Serial)\n\n    # We tell Geant what construction, physics list and action to use\n    # These classes need to be defined by us\n    runManager.SetUserInitialization(ConstructionDefinition())\n    runManager.SetUserInitialization(PhysicsListDefinition())\n    runManager.SetUserInitialization(ActionDefinition())\n\n    # We initialise the Geant4 manage\n    runManager.Initialize()\n\n    # We prepare and initialise the GUI\n    ui = G4UIExecutive()\n    visManager = G4VisExecutive()\n    visManager.Initialize()\n\n    # We can send commands (e.g. create particles) from \n    # the GUI or from here already using the UImanager\n    UImanager = G4UImanager.GetUIpointer()\n\n    # Commands are applied like this: \n    # this one tells the UI to run 10 particles\n    UImanager.ApplyCommand(f\"/run/beamOn {int(nParticles)}\")\n\n    # Finally we start the session\n    ui.SessionStart()\n\n# This will automatically call the main function \n# when we write `python mainFile.py` to the terminal\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"szd2/geant/geant4.html#construction-definition","title":"Construction definition","text":"<p>Detector / volume construction is performed in three steps:</p> <ul> <li>Solid volume - definition of shape and proportions</li> <li>Logical volume - definition of the material</li> <li>Physical volume - setting the volume in space</li> </ul> <p>The implementation is performed via the <code>G4VUserDetectorConstruction</code> class.</p> <p>For demonstration, we create a golden plate in a vacuum. First we create the \"vacuum box\":</p> C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction { // (1)!\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); // (2)!\n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> <ol> <li>We derive our class from the <code>G4VUserDetectorConstruction</code> class.</li> <li>This is the actual method that we will use in the <code>src/construction.cc</code> to construct the volume (see bellow).</li> </ol> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n\n// We include the header file\n#include \"../include/construction.hh\" // (1)!\n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; // (7)!\n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); // (2)!\n\n    // VACUUM BOX CONSTRUCTION\n    auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); // (3)!\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, worldMaterial, \"World\"); // (5)!\n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  // (6)!\n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n}\n</code></pre> <ol> <li>This header file must include the definition of the classes that are implemented in this file.   </li> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length. List of other shapes.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it. The last argument is the (arbitrary) name.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>#include &lt;G4SystemOfUnits.hh&gt;</code> we can use the standard units (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm # (6)!\n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() # (1)!\n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") # (2)!\n\n        # VACUUM BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) # (3)!\n        logicWorld = G4LogicalVolume(solidWorld, world_material, name=\"World\") # (4)!\n\n        physWorld = G4PVPlacement(None,  # (5)!\n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n</code></pre> <ol> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>from geant4_pybind import *</code> we also imported the units namelist from Geant4 and therefore we can use the standard units like this (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> </ol> <p>Similarly, we can implement the golden foil itself: we need to use different dimension, different material, and we want to place the foil inside the vacuum box  we select the vacuum box as the parent volume. We continue in the <code>Construct</code> method:</p> C++Python src/construction.cc<pre><code>...\n// The construction method that we worked with\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // Implementation of the vacuum box from above\n    ...\n\n    // After that, we want to add the golden foil\n    auto *foilMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Au\");\n    auto *solidFoil = new G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ);\n    auto *logicFoil = new G4LogicalVolume(solidFoil, foilMaterial, \"Foil\");\n\n    G4VPhysicalVolume *physFoilVolume = new G4PVPlacement(nullptr,                  // no rotation\n                                                        G4ThreeVector(0., 0., 0.),  // position in the center\n                                                        logicFoil,                  // corresponding logical volume\n                                                        \"Foil\",                     // name\n                                                        logicWorld,                 // parent volume\n                                                        false,                      // no multiples\n                                                        0,                          // no copies\n                                                        true);                      // check for overlaps\n                                                        //(1)! \n}\n</code></pre> <ol> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # Implementation of the vacuum box from above\n        ...\n\n        # After that, we want to add the golden foil\n        foil_material = nist.FindOrBuildMaterial(\"G4_Au\")\n        solidFoil = G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ)\n        logicFoil = G4LogicalVolume(solidFoil, foil_material, name=\"Foil\")\n        physFoil = G4PVPlacement(None,              # no rotation\n                                G4ThreeVector(),    # position in the center\n                                logicFoil,          # corresponding logical volume\n                                \"Foil\",             # name\n                                logicWorld,         # parent volume \n                                True,               # no multiples\n                                0,                  # no copies\n                                True)               # check for overlaps\n                                # (1)! \n</code></pre> <ol> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> Full example C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction { // (1)!\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); // (2)!\n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> <ol> <li>We derive our class from the <code>G4VUserDetectorConstruction</code> class.</li> <li>This is the actual method that we will use in the <code>src/construction.cc</code> to construct the volume (see bellow).</li> </ol> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n\n// We include the header file\n#include \"../include/construction.hh\" // (1)!\n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; // (7)!\n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); // (2)!\n\n    // VACUUM BOX CONSTRUCTION\n    auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); // (3)!\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, worldMaterial, \"World\"); // (5)!\n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  // (6)!\n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n\n    // After that, we want to add the golden foil\n    auto *foilMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Au\");\n    auto *solidFoil = new G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ);\n    auto *logicFoil = new G4LogicalVolume(solidFoil, foilMaterial, \"Foil\");\n\n    G4VPhysicalVolume *physFoilVolume = new G4PVPlacement(nullptr,                  // no rotation\n                                                        G4ThreeVector(0., 0., 0.),  // position in the center\n                                                        logicFoil,                  // corresponding logical volume\n                                                        \"Foil\",                     // name\n                                                        logicWorld,                 // parent volume\n                                                        false,                      // no multiples\n                                                        0,                          // no copies\n                                                        true);                      // check for overlaps\n                                                        //(8)! \n}\n</code></pre> <ol> <li>This header file must include the definition of the classes that are implemented in this file.   </li> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it. The last argument is the (arbitrary) name.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: </li> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> <li>Thanks to <code>#include &lt;G4SystemOfUnits.hh&gt;</code> we can use the standard units (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm # (6)!\n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() # (1)!\n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") # (2)!\n\n        # VACUUM BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) # (3)!\n        logicWorld = G4LogicalVolume(solidWorld, world_material, name=\"World\") # (4)!\n\n        physWorld = G4PVPlacement(None,  # (5)!\n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n\n        # After that, we want to add the golden foil\n        foil_material = nist.FindOrBuildMaterial(\"G4_Au\")\n        solidFoil = G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ)\n        logicFoil = G4LogicalVolume(solidFoil, foil_material, name=\"Foil\")\n        physFoil = G4PVPlacement(None,              # no rotation\n                                G4ThreeVector(),    # position in the center\n                                logicFoil,          # corresponding logical volume\n                                \"Foil\",             # name\n                                logicWorld,         # parent volume \n                                True,               # no multiples\n                                0,                  # no copies\n                                True)               # check for overlaps\n                                # (7)! \n</code></pre> <ol> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length. List of other shapes.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>from geant4_pybind import *</code> we also imported the units namelist from Geant4 and therefore we can use the standard units like this (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> <p>Info</p> <p>Apart from the box that we have used, there are also other shapes (sphere, cone, ...), see the list of shapes.</p>"},{"location":"szd2/geant/geant4.html#definition-of-custom-material","title":"Definition of custom material","text":"<p>All elements are predefined in Geant4, the list of them can be found here. However, sometimes we need to create a compound from different elements. </p> <p>For this we define our own material via the <code>G4Material</code> class. We define the density of the material and number of components, which we will add.</p> C++Python <pre><code>#include \"G4Material.hh\"\n#include \"G4Element.hh\"\n#include \"G4NistManager.hh\"\n\n// Get the predefined elements that our material comprises of\nG4Element* C = G4NistManager::Instance()-&gt;FindOrBuildElement(\"C\");\nG4Element* O = G4NistManager::Instance()-&gt;FindOrBuildElement(\"O\");\nG4Element* N = G4NistManager::Instance()-&gt;FindOrBuildElement(\"N\");\n\n// Define the material\nG4Material* MyMaterial = new G4Material(\"MyMaterial\", 1.2*g/cm3, 3); // name of the material, density, number of elements\nMyMaterial-&gt;AddElement(C, 0.5); // 50% Carbon by weight\nMyMaterial-&gt;AddElement(O, 0.3); // 30% Oxygen by weight\nMyMaterial-&gt;AddElement(N, 0.2); // 20% Nitrogen by weight\n</code></pre> <pre><code>from geant4_pybind import *\n\n# Get the predefined elements that our material comprises of\nC = G4Element.GetElement(\"C\")\nO = G4Element.GetElement(\"O\")\nN = G4Element.GetElement(\"N\")\n\n# Define the material\nMyMaterial = G4Material(\"MyMaterial\", 1.2*g/cm3, 3) # name of the material, density, number of elements\nMyMaterial.AddElement(C, 0.5)  # 50% Carbon by weight\nMyMaterial.AddElement(O, 0.3)  # 30% Oxygen by weight\nMyMaterial.AddElement(N, 0.2)  # 20% Nitrogen by weight\n</code></pre> <p>Info</p> <p>The material definition would be performed inside the <code>Construct</code> method in the <code>G4VUserDetectorConstruction</code> that we work with. </p> <p>In other words, replace the line with <code>FindOrBuildMaterial</code> in the codes here by the lines above. </p> Full example C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction {\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); \n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n#include \"G4Element.hh\"\n\n// We include the header file\n#include \"../include/construction.hh\" \n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; \n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); \n\n    // BOX CONSTRUCTION\n    // (1)!\n    // auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); \n\n    // Get the predefined elements that our material comprises of\n    G4Element* C = G4NistManager::Instance()-&gt;FindOrBuildElement(\"C\");\n    G4Element* O = G4NistManager::Instance()-&gt;FindOrBuildElement(\"O\");\n    G4Element* N = G4NistManager::Instance()-&gt;FindOrBuildElement(\"N\");\n\n    // Define the material\n    G4Material* MyMaterial = new G4Material(\"MyMaterial\", 1.2*g/cm3, 3); // name of the material, density, number of elements\n    MyMaterial-&gt;AddElement(C, 0.5); // 50% Carbon by weight\n    MyMaterial-&gt;AddElement(O, 0.3); // 30% Oxygen by weight\n    MyMaterial-&gt;AddElement(N, 0.2); // 20% Nitrogen by weight\n\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, MyMaterial, \"World\"); \n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  \n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n}\n</code></pre> <ol> <li>This is what we used before in the main file. We replace it by our own material.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm \n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() \n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        # (1)!\n        # world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") \n\n        # Get the predefined elements that our material comprises of\n        C = G4Element.GetElement(\"C\")\n        O = G4Element.GetElement(\"O\")\n        N = G4Element.GetElement(\"N\")\n\n        # Define the material\n        MyMaterial = G4Material(\"MyMaterial\", 1.2*g/cm3, 3) # name of the material, density, number of elements\n        MyMaterial.AddElement(C, 0.5)  # 50% Carbon by weight\n        MyMaterial.AddElement(O, 0.3)  # 30% Oxygen by weight\n        MyMaterial.AddElement(N, 0.2)  # 20% Nitrogen by weight\n\n        # BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) \n        logicWorld = G4LogicalVolume(solidWorld, MyMaterial, name=\"World\") \n\n        physWorld = G4PVPlacement(None,  \n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n</code></pre> <ol> <li>This is what we used before in the main file. We replace it by our own material.</li> </ol> <p>For advanced, the <code>G4Element</code> can be defined by us: this can be useful when we want to use specific isotopic composition. See the example bellow, where we want to create LiH with two different isotopes of lithium.</p> C++Python <pre><code>G4Material *LiH = new G4Material(\"LiH\", 0.78*g/cm3, 2); // name, density\nG4Isotope *Li7 = new G4Isotope(\"Li7\", 3, 7); // name, atomic number Z, nucleon number N\nG4Isotope *Li6 = new G4Isotope(\"Li6\", 3, 6); // name, atomic number Z, nucleon number N\nG4Element *Li = new G4Element(\"Li\", \"Li\", 2); // name, symbol, number of isotopes\n\n// We add the isotopes to Li\nLi-&gt;AddIsotope(Li7, 5*perCent); // what isotope we add, its percentage\nLi-&gt;AddIsotope(Li6, 95*perCent); // what isotope we add, its percentage\n\n// Finaly we make the LiH: which means adding 1 atom of Li and 1 atom of H\nLiH-&gt;AddElement(Li, 1); // element we are adding, number of atoms\nLiH-&gt;AddElement(nist-&gt;FindOrBuildElement(\"H\"), 1); // element we are adding, number of atoms\n</code></pre> <pre><code>LiH = G4Material(\"LiH\", 0.78*g/cm3, 2) # name, density\nLi7 = G4Isotope(\"Li7\", 3, 7)  # name, atomic number Z, nucleon number N\nLi6 = G4Isotope(\"Li6\", 3, 6)  # name, atomic number Z, nucleon number N\nLi = G4Element(\"Li\", \"Li\", 2) # name, symbol, number of isotopes\n\n# We add the isotopes to Li\nLi.AddIsotope(Li7, 5*perCent) # what isotope we add, its percentage\nLi.AddIsotope(Li6, 95*perCent) # what isotope we add, its percentage\n\n# Finaly we make the LiH: which means adding 1 atom of Li and 1 atom of H\nLiH.AddElement(Li, 1) # element we are adding, number of atoms\nLiH.AddElement(nist.FindOrBuildElement(\"H\"), 1) # element we are adding, number of atoms\n</code></pre>"},{"location":"szd2/geant/geant4.html#physics-list-definition","title":"Physics list definition","text":"<p>One could either define own physics list or use a predefined one. </p>"},{"location":"szd2/geant/geant4.html#using-predefined-physics-list","title":"Using predefined physics list","text":"<p>To use a predefined physics list, we need to create an instance of that physics list in the main file and set in using the <code>SetUserInitialization</code> method. In this case, we no longer need the <code>physicsList.hh</code> and <code>physicsList.cc</code> files. </p> C++Python mainFile.cc<pre><code>#include \"QBBC.hh\"\n// other includes\n// (1)!\nint main(int argc, char** argv){\n    ...\n    G4VModularPhysicsList *physicsList = new QBBC; // QGSC + BinaryCascade + Bertini + CHIPS\n    //physicsList-&gt;RegisterPhysics (new G4OpticalPhysics()); // Cv. part one\n    runManager-&gt;SetUserInitialization(physicsList); // adds physics list\n    ...\n}\n</code></pre> <ol> <li>This is the main file presented in the Main file section.</li> </ol> mainFile.py<pre><code>from geant4_pybind import *\n# (1!\ndef main():\n    ...\n    runManager.SetUserInitialization(QBBC()) # QGSC + BinaryCascade + Bertini + CHIPS\n    ...\n</code></pre> <ol> <li>This is the main file presented in the Main file section.</li> </ol> <p>In other words, there is only change in the main file depending on what predefined physics list we choose.</p> <p>Info</p> <p>Find the list of predefined physics list here.</p>"},{"location":"szd2/geant/geant4.html#using-own-physics-list","title":"Using own physics list","text":"<p>To define own physics list, we will use the <code>G4VModularPhysicsList</code> class.</p> C++Python include/physicsList.hh<pre><code>#ifndef PHYSICSLIST_HH\n#define PHYSICSLIST_HH\n\n#include &lt;G4VModularPhysicsList.hh&gt;\n\nclass PhysicsList : public G4VModularPhysicsList{\npublic:\n    PhysicsList();\n    ~PhysicsList();\n};\n\n#endif //PHYSICSLIST_HH\n</code></pre> src/physicsList.cc<pre><code>#include &lt;G4EmStandardPhysics.hh&gt;\n#include &lt;G4DecayPhysics.hh&gt;\n#include &lt;G4EmLowEPPhysics.hh&gt;\n\n#include \"../include/physicsList.hh\"\n\nPhysicsList::PhysicsList() {\n    RegisterPhysics (new G4EmStandardPhysics());\n    RegisterPhysics (new G4EmLowEPPhysics());\n    RegisterPhysics(new G4DecayPhysics());\n}\n\nPhysicsList::~PhysicsList() {};\n</code></pre> mainFile.py or physicsList.py<pre><code>from geant4_pybind import *\n\n    class PhysicsList(G4VModularPhysicsList):\n\n    def __init__(self):\n        super().__init__()\n\n        # Default physics\n        self.RegisterPhysics(G4DecayPhysics())\n\n        # EM physics\n        self.RegisterPhysics(G4EmStandardPhysics())\n\n        # Decay physics\n        self.RegisterPhysics(G4DecayPhysics())\n</code></pre> <p>Note that the <code>mainFile.cc</code> of <code>mainFile.py</code> would be exactly same as here in this case. </p>"},{"location":"szd2/geant/geant4.html#action-definition","title":"Action definition","text":"<p>The action class allows us to define, among others, particle definition and particle detection. </p> <p>We will inherit from <code>G4VUserActionInitialization</code> class for our action class.</p> C++Python include/action.hh<pre><code>#ifndef ACTION_HH\n#define ACTION_HH\n\n#include &lt;G4VUserActionInitialization.hh&gt;\n\nclass ActionInitialization : public G4VUserActionInitialization {\npublic:\n    ActionInitialization();\n    ~ActionInitialization();\n    virtual void Build() const; // this is the method that we will work with\n};\n\n\n#endif //ACTION_HH\n</code></pre> src/action.cc<pre><code>#include \"../include/action.hh\"\n\nActionInitialization::ActionInitialization() = default;\n\nActionInitialization::~ActionInitialization() = default;\n\nvoid ActionInitialization::Build() const {\n    // we will add our actions here\n\n}\n</code></pre> mainFile.py or action.py<pre><code>from geant4_pybind import *\n\nclass ActionInitialization(G4VUserActionInitialization):\n    def Build(self):\n        # we will add our actions here\n        pass\n</code></pre> <p>Now, we have the main action class. Now we may define various actions (e.g. particle generation) and then insert the back into the <code>Build</code> method, that will be triggered for each event, in the first run, in the last run ...</p>"},{"location":"szd2/geant/geant4.html#define-primary-particle-generation","title":"Define primary particle generation","text":"<p>For generation of primary particles, we will make use of </p> <ul> <li><code>G4VUserPrimaryGeneratorAction</code> class to specify the particle and trigger the generation during the run,</li> <li><code>G4ParticleGun</code> class to generate the particles.</li> </ul> <p>In this example, we define 100 MeV electrons with momentum in the forward (z) direction only.</p> C++Python <p>We need to create two additional files: <code>include/particleGenerator.hh</code> and <code>src/particleGenerator.cc</code>.</p> include/particleGenerator.hh<pre><code>#ifndef PARTICLEGENERATOR_HH\n#define ARTICLEGENERATOR_HH\n\n#include &lt;G4VUserPrimaryGeneratorAction.hh&gt;\n#include &lt;G4ParticleGun.hh&gt;\n\nclass particleGenerator : public G4VUserPrimaryGeneratorAction {\npublic:\n    particleGenerator();\n    ~particleGenerator();\n\n    // all setup will be defined in this method\n    virtual void GeneratePrimaries(G4Event *anEvent);\nprivate:\n    G4ParticleGun *fParticleGun; // this is the particle gun itself\n};\n\n\n#endif //PARTICLEGENERATOR_HH\n</code></pre> src/particleGenerator.cc<pre><code>#include \"../include/particleGenerator.hh\"\n#include &lt;G4ParticleTable.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n\n// CONSTRUCTOR\nparticleGenerator::particleGenerator(){\n    // we create the particle generator itself\n    fParticleGun = new G4ParticleGun(1); // argument is the number of primary vertices, see the comment box bellow\n\n    // select electron\n    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();\n    G4String particleName;\n    G4ParticleDefinition* particle\n            = particleTable-&gt;FindParticle(particleName=\"e-\"); // (1)!\n\n    // we tell the particle gun to create an electron ...\n    fParticleGun-&gt;SetParticleDefinition(particle);\n    // ... in the forward (z) direction ...\n    fParticleGun-&gt;SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.)); // x, y, z\n    // ... with energy of 100 MeV ...\n    fParticleGun-&gt;SetParticleEnergy(100. * MeV);\n    // ... and the position of the source\n    fParticleGun-&gt;SetParticlePosition(G4ThreeVector(0, 0, -0.5 * cm)); // x, y, z\n\n}\n\n// DESTRUCTOR\nparticleGenerator::~particleGenerator(){\n    delete fParticleGun;\n}\n\n// this is the method that generates the particles for each event\nvoid particleGenerator::GeneratePrimaries(G4Event *anEvent) {\n    fParticleGun-&gt;GeneratePrimaryVertex(anEvent);\n}\n</code></pre> <ol> <li>Most particles are already predefined, so we use the predefined electron.</li> </ol> <pre><code>from geant4_pybind import *\n\nclass particleGenerator(G4VUserPrimaryGeneratorAction):\n    def __init__(self, electronEnergy):\n        super().__init__()\n\n        # we create the particle generator itself\n        self.fParticleGun = G4ParticleGun(1) # argument is the number of primary vertices, see the comment box bellow\n\n        # we tell the particle gun to create an electron ...\n        self.fParticleGun.SetParticleDefinition(G4Electron.Definition())\n        # ... in the forward (z) direction ...\n        self.fParticleGun.SetParticleMomentumDirection(G4ThreeVector(0, 0, 1)) # x, y, z\n        # ... with energy of 100 MeV ...\n        self.fParticleGun.SetParticleEnergy(100 * MeVs)\n        # ... and the position of the source\n        self.fParticleGun.SetParticlePosition(G4ThreeVector(0, 0, -0.5 * cm)) # x, y, z \n\n    def GeneratePrimaries(self, event):\n        self.fParticleGun.GeneratePrimaryVertex(event)\n</code></pre> <p>Info</p> <p>When creating the particle gun using the <code>G4ParticleGun</code> class, we used <code>1</code> as the argument: this is the number of primary vertices. However, typically, we want to simulate more than one particle to gain some statistics.</p> <p>This is because the convention in Geant4 is to generate one particle per event and have the number of events corresponding to the total number of particles we want to simulate. </p> <p>Also note, that there are no collective effects implemented into Geant4: therefore, multiple primary particles generated in the event do not affect each other. </p> <p>Info</p> <p>Note that we are using the standard units (cm, MeV). This is thanks to the <code>#include &lt;G4SystemOfUnits.hh&gt;</code> in <code>C++</code> and  <code>from geant4_pybind import *</code> in <code>Python</code>.</p> <p>Finally, we need to add this action to the main action class created in Action definition.</p> C++Python src/action.cc<pre><code>#include \"../include/action.hh\"\n#include \"../include/particleGenerator.hh\"\n\nActionInitialization::ActionInitialization() = default;\n\nActionInitialization::~ActionInitialization() = default;\n\nvoid ActionInitialization::Build() const {\n    // particle generation action\n    auto generator = new particleGenerator();\n    SetUserAction(generator);\n}\n</code></pre> mainFile.py or action.py<pre><code>class ActionInitialization(G4VUserActionInitialization):\n    def Build(self):\n        generator = particleGenerator() # (1)!\n        self.SetUserAction(generator)\n</code></pre> <ol> <li>Provided that the definition of <code>particleGenerator</code> class is in the same file or is properly imported (it is the class that we created at the beginning of Define primary particle section).</li> </ol>"},{"location":"szd2/geant/geant4.html#define-particle-detection","title":"Define particle detection","text":""},{"location":"szd2/geant/geant4.html#running-the-simulation","title":"Running the simulation","text":"C++Python <p>The environment with Geant4 must be correctly intialized.</p> <p>Due to the multiple files we have, we will use CMake for compilation, so the top directory must contain the <code>CMakeLists.txt</code> file. This is already set up in the provided examples.</p> Sample <code>CMakeLists.txt</code> <p>In the provided examples, the <code>CMakeLists.txt</code> is already set up. Nevertheless, when working with the file structure</p> <pre><code>mainFile.cc\nCMakeLists.txt\ninclude/\n    construction.hh\n    physicsList.hh\n    action.hh\nsrc/\n    construction.cc\n    physicsList.cc\n    action.cc\n</code></pre> <p>The <code>CMakeLists.txt</code> contains:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)\n\nproject(example)\n\nfind_package(Geant4 REQUIRED ui_all vis_all)\n\ninclude(${Geant4_USE_FILE})\n\nfile(GLOB sources ${PROJECT_SOURCE_DIR}/src/*.cc)\nfile(GLOB headers ${PROJECT_SOURCE_DIR}/include/*.hh)\n\nadd_executable(mainFile mainFile.cc ${sources} ${headers}\n        include/construction.hh\n        src/physicsList.cc\n        src/action.cc\n        include/construction.hh\n        include/physicsList.hh\n        include/action.hh)\ntarget_link_libraries(mainFile ${Geant4_LIBRARIES})\n\nadd_custom_target(mainFileCC DEPENDS mainFile)\n</code></pre> <p>During the first build, one must run (from the top directory including <code>CMakeLists.txt</code>)</p> <pre><code>mkdir build\ncd build\ncmake ..\n</code></pre> <p>This will setup the build directory. Now we can build and run the program inside the build directory</p> <pre><code>make\n./mainFile\n</code></pre> <p>After editing the code, we have to rebuild the project using the <code>make</code> command.</p> <p>Python environment with Geant4 must be correctly initialized first. After that, we write into the terminal</p> <pre><code>python mainFile.py\n</code></pre>"}]}