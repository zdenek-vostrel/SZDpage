{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Statistick\u00e9 zpracov\u00e1n\u00ed dat | statistical data analysisis","text":"<p>Hi! This is a page that supporting the SZD subject at FNSPE. It is meant to provide context to the codes that you will come across during the two semesters and also introduce some Python tools that can be used for related problems.</p> <p>The page is still in development, so please report any issues or provide feedback to M\u00edra My\u0161ka.</p> <p>See the corresponding bookmarks for additional information: </p> <ul> <li>SZD1</li> <li>SZD2</li> </ul>"},{"location":"tags.html","title":"Homework","text":""},{"location":"tags.html#szd1-homework","title":"SZD1 Homework","text":"<ul> <li>The three door problem</li> </ul>"},{"location":"szd1/index.html","title":"SZD1","text":""},{"location":"szd1/DAlembert.html","title":"D'Alembert Strategy","text":"<p>The d'Alembert strategy is a betting system often used in gambling. It is named after the French mathematician Jean le Rond d'Alembert. The strategy is based on the idea of balancing wins and losses, and it is considered a more conservative approach compared to other betting systems like the Martingale.</p>"},{"location":"szd1/DAlembert.html#how-the-dalembert-strategy-works","title":"How the d'Alembert Strategy Works","text":"<ol> <li> <p>Initial Bet: You start with a base bet, which is the amount you choose to wager initially.</p> </li> <li> <p>Increasing Bets: If you lose a bet, you increase your next bet by one unit. For example, if your base bet is $10 and you lose, your next bet would be $20.</p> </li> <li> <p>Decreasing Bets: If you win a bet, you decrease your next bet by one unit. So, if you win after betting $20, your next bet would return to $10.</p> </li> <li> <p>Goal: The goal of the d'Alembert strategy is to achieve a balance between wins and losses over time, with the idea that the number of wins and losses will eventually even out.</p> </li> </ol> AI's illustration :)"},{"location":"szd1/DAlembert.html#theory","title":"Theory","text":"<p>We suppose there are two possible outcomes of the game, red and black, with the same probability $$ P(R) = 1/2 = P(B). $$</p> <p>Intuition would suggest</p> \\[ P(R |\\text{previous was black}) &gt; P(R) &gt; P(R |\\text{previous was red}), \\] <p>because the number of red and black outcomes should balance over time. This is the core of the D'Alembert strategy.</p> <p>However, this is wrong, as can be illustrated by the simulations. Each round is independent of the previous one, therefore by definition of the conditional probability</p> \\[ P(R |\\text{previous was black}) = P(R) = P(R |\\text{previous was red}). \\]"},{"location":"szd1/DAlembert.html#code","title":"Code","text":"PythonC++ and ROOT <p>The code bellow compares the D'Alembert strategy with two other strategies:</p> <ul> <li>Always bet the same: the bet is the same in every run, regardless the output of the previous round.</li> <li>Random bet: the decision of whether the bet should be increased or decreased before each round is randomized.</li> </ul> <p>The strategies are compared by multiple simulated games with a fixed number of runs. </p> <p>Note</p> <p>The implementation of the D'Alembert strategy is higlighted in the code bellow.</p> <pre><code>import random\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pathlib\n\ndef main():\n    # Parameters\n    initial_balance = 200           # Initial balance\n    base_bet = 20                   # Initiabl bet\n    bet_change = 5                  # Change of the bet\n    rounds = 20                     # Maximum number of rounds\n    number_of_simulations = 1000    # Nummber of simulations\n\n    # Results       \n    final_balance_DAlembert = []    \n    final_balance_sameBet = []   \n    final_balance_randomBet = []    \n\n    for sim in range(number_of_simulations):\n        # Start of the simulation\n        final_balance_DAlembert += [d_alembert_strategy(initial_balance, base_bet, rounds, bet_change)]\n        final_balance_sameBet += [always_bet_the_same(initial_balance, base_bet, rounds)]\n        final_balance_randomBet += [random_bet_change(initial_balance, base_bet, rounds, bet_change)]\n\n    plot(final_balance_DAlembert, final_balance_sameBet, final_balance_randomBet, initial_balance)\n\n\ndef plot(final_balance_DAlembert, final_balance_sameBet, final_balance_randomBet, initial_balance):\n    fig, ax = plt.subplots()\n\n    x = np.arange(len(final_balance_DAlembert))+1\n\n    ax.hist(x, bins=x, weights=final_balance_DAlembert, align=\"mid\", histtype=\"step\", facecolor=\"none\", alpha=.5, label=\"D'Alembert\")\n    m = np.mean(final_balance_DAlembert)\n    s = np.std(final_balance_DAlembert)/np.sqrt(len(final_balance_DAlembert))\n    ax.plot([x[0], x[-1]], [m,m], linestyle=\"--\", c=\"C0\", label=f\"D'Alembert mean ({m:.1f} $\\pm$ {s:.1f})\")\n\n    ax.hist(x, bins=x, weights=final_balance_sameBet, align=\"mid\", histtype=\"step\", facecolor=\"none\", alpha=.5, label=\"Constant bet\")\n    m = np.mean(final_balance_sameBet)\n    s = np.std(final_balance_sameBet)/np.sqrt(len(final_balance_sameBet))\n    ax.plot([x[0], x[-1]], [m,m], linestyle=\"--\", c=\"C1\", label=f\"Constant bet mean ({m:.1f} $\\pm$ {s:.1f})\")\n\n    ax.hist(x, bins=x, weights=final_balance_randomBet, align=\"mid\", histtype=\"step\", facecolor=\"none\", alpha=.5, label=\"Random bet\")\n    m = np.mean(final_balance_randomBet)\n    s = np.std(final_balance_randomBet)/np.sqrt(len(final_balance_randomBet))\n    ax.plot([x[0], x[-1]], [m,m], linestyle=\"--\", c=\"C2\", label=f\"Random bet mean ({m:.1f} $\\pm$ {s:.1f})\")\n\n    ax.plot([x[0], x[-1]], [initial_balance, initial_balance], linestyle=\"--\", c=\"black\", label=\"Initial balance\")\n\n    plt.ylabel(\"Balance at the end of the game\")\n    plt.xlabel(\"Game number\")\n\n    plt.legend()\n\n    fName = pathlib.Path(\"DAlembert.png\")\n    fig.savefig(fName, dpi=250)\n\ndef d_alembert_strategy(initial_balance, base_bet, rounds, bet_change):\n    balance = initial_balance\n    current_bet = base_bet\n\n    for r in range(rounds):\n        if balance &lt; current_bet:\n            break\n\n        # Result of the simulation (0 = loss, 1 = win)\n        result = random.choice([0, 1])  # 0 = loss, 1 = win\n\n        if result == 1:  # Win\n            balance += current_bet\n            current_bet = max(1, current_bet - bet_change)  # Decrease of the bet\n        else:  # Loss\n            balance -= current_bet\n            current_bet += bet_change  # Increase of the bet\n\n    return balance\n\ndef always_bet_the_same(initial_balance, base_bet, rounds):\n    balance = initial_balance\n    current_bet = base_bet\n\n    for r in range(rounds):\n        if balance &lt; current_bet:\n            break\n\n        # Result of the simulation (0 = loss, 1 = win)\n        result = random.choice([0, 1])  # 0 = loss, 1 = win\n\n        if result == 1:  # Win\n            balance += current_bet\n        else:  # Loss\n            balance -= current_bet\n\n    return balance\n\ndef random_bet_change(initial_balance, base_bet, rounds, bet_change):\n    balance = initial_balance\n    current_bet = base_bet\n\n    for r in range(rounds):\n        if balance &lt; current_bet:\n            break\n\n        # Result of the simulation (0 = loss, 1 = win)\n        result = random.choice([0, 1])  # 0 = loss, 1 = win\n\n        if result == 1:  # Win\n            balance += current_bet\n        else:  # Loss\n            balance -= current_bet\n\n        current_bet = random.choice([current_bet + bet_change, max(1, current_bet-bet_change)])\n\n    return balance\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Output <p>The output is a plot illustrating the comparison of the three strategies and the average end of the game balance. </p> <p>Notice that all three results are the same within their errors, meaning that the D'Alembert strategy in this form does not lead to significantly better results. This is because of the independance of the outputs of each of the rounds, as discussed at the end of the theory section.</p> <p>Advanced</p> <p>Try to rewrite the code so that the <code>for</code> loop is avoided and the problem is solved via the vectorized approach.</p> <p>The code bellow is the simulation of the D'Alembert strategy.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // For rand() and srand()\n#include &lt;ctime&gt;   // For time()\n#include &lt;TH1D.h&gt; // ROOT histogram class\n#include &lt;TROOT.h&gt; // ROOT main class\n\n// Main function to simulate D'Alembert's strategy\nvoid DAlemberts_strategy() {\n    // Load ROOT macros for styling\n    gROOT-&gt;LoadMacro(\"/home/mira/local/atlasstyle-00-03-05/AtlasStyle.C\");\n    gROOT-&gt;LoadMacro(\"/home/mira/local/atlasstyle-00-03-05/AtlasUtils.C\");\n\n    // Declare a histogram to store results\n    TH1D* h_total;\n\n    int super_total = 0; // Variable to accumulate total results\n    int number_of_games = 100; // Number of games to simulate\n\n    // Initialize histogram for total results\n    h_total = new TH1D(\"total\", \"total\", 100, 0.5, 100.5);\n    h_total-&gt;SetXTitle(\"Number of Bets\");\n    h_total-&gt;SetYTitle(\"Total Amount\");\n    h_total-&gt;Sumw2(); // Enable error calculation for the histogram\n\n    // Loop through the number of games\n    for (int n = 1; n &lt;= number_of_games; n++) {\n        int total = 200; // Starting capital\n        int bet = 10;    // Initial bet amount\n        int min_bet = 1; // Minimum bet amount\n\n        // Simulate 100 rounds of betting\n        for (int i = 1; i &lt;= 100; i++) {\n            // Check if the bet is valid\n            if (bet &lt; min_bet || total &lt; bet) break;\n\n            // Generate a random outcome (0 = loss, or 1 = win)\n            int j = rand() % 2;\n\n            // Update total and bet based on the outcome\n            if (j == 0) { // Loss\n                total -= bet; // Lose the bet\n                bet++;        // Increase the bet for the next round\n            } else { // Win\n                total += bet; // Win the bet\n                bet--;        // Decrease the bet for the snext round\n            }\n        }\n\n        // Accumulate the total results\n        super_total += total;\n        h_total-&gt;Fill((n - 0.5), total); // Fill histogram with the total for this game\n    }\n\n    // Adjust super_total by subtracting the initial capital for all games\n    super_total -= (number_of_games * 200);\n    std::cout &lt;&lt; super_total &lt;&lt; std::endl; // Output the final result\n    h_total-&gt;Draw(\"hist\"); // Draw the histogram\n}\n</code></pre> Output <p>The output of the programe is a plot of the balance at the end of the game for multiple runs. It also prints in the terminal the total loss / win.</p> <p>Advanced</p> <p>Try to implement other strategies (random bet, constant bet,...) for comparison.</p>"},{"location":"szd1/doors.html","title":"The three door problem","text":"<p>The \"three door problem,\" commonly known as the Monty Hall problem, is a probability puzzle based on a game show scenario. Here is how it works:</p> <ol> <li>Setup: There are three doors: behind one door is a car (the prize you want), and behind the other two doors are goats (which you do not want).</li> <li>Initial Choice: You, the contestant, choose one of the three doors. Let's say you choose Door 1.</li> <li>Host Action: The host, who knows what is behind each door, then opens one of the other two doors, revealing a goat. For example, if you chose Door 1, the host might open Door 3, showing a goat.</li> <li>Final Decision: You are then given the option to either stick with your original choice (Door 1) or switch to the remaining unopened door (Door 2).</li> </ol> <p>Question: What should you do to maximize your chances of winning the car?</p> AI's depiction of the problem :)","tags":["SZD1 Homework"]},{"location":"szd1/doors.html#theory","title":"Theory","text":"<p>Let us number the doors 1,2 and 3. Without loss of generality, let us select door number 1. The probability that the prize is behind this door is simply</p> \\[ P(\\text{prize behind  }1) = 1/3. \\] <p>Now the host has to open either door number 2 or number 3. Since they are indistinguishable to us at this moment, let us suppose the host opens door number 3, indicating the prize is not behind them. Then the probability of the prize being behind door number 2 is, by definition, $$ P(\\text{prize behind  }2 | 3 \\text{ is opened}) = \\frac{P(3\\text{ is opened} | \\text{prize behind  }2) \\cdot P(\\text{prize behind  }2)}{P(3\\text{ is opened})}. $$</p> <p>Now we have to evaluate each of the probabilities on the right-hand side:</p> <ol> <li>The probability \\(P(3\\text{ is opened} | \\text{prize behind  }2)\\) (door number 3 is opened provided that the prize is behind the door number two) is fairly simple to evaluate. If the prize is behind the door number 2 and we have previously selected the door number 1, the host cannot open either of them. Therefore, the host must open the door number 3, and so \\(P(3\\text{ is opened} | \\text{prize behind  }2) = 1\\).</li> <li>\\(P(\\text{prize behind  }2)=1/3\\) because the probability of the prize being behind each of the three doors is equal.</li> <li> <p>To evaluate the denominator, we use the law of total probability     $$     P(3\\text{ is opened}) = P(3\\text{ is opened} | \\text{prize behind  }1)\\cdot P(\\text{prize behind  }1)      $$</p> \\[ +  P(3\\text{ is opened} | \\text{prize behind  }2)\\cdot P(\\text{prize behind  }2)  \\] \\[ +  P(3\\text{ is opened} | \\text{prize behind  }3)\\cdot P(\\text{prize behind  }3) \\] <ul> <li>We have established that \\(P(\\text{prize behind  }i) =1/2\\quad \\forall i  \\in \\{1,2,3\\}\\).</li> <li>\\(\\cdot P(\\text{prize behind  }1) = 1/2\\) because the host can open door number 2 or 3 (the prize is not behind either of them and we did not pick them) with the same probablity.</li> <li>\\(P(3\\text{ is opened} | \\text{prize behind  }2) = 1\\) as we have already discussed.</li> <li>\\(P(3\\text{ is opened} | \\text{prize behind  }3) = 0\\) because the host can not open the door if the prize is behind them.</li> </ul> <p>And therefore </p> \\[ P(3\\text{ is opened}) = 1/2 \\cdot 1/3 + 1 \\cdot 1/3 + 0 = 1/2. \\] </li> </ol> <p>With these calculations, we can finally evaluate</p> \\[ P(\\text{prize behind  }2 | 3 \\text{ is opened}) = \\frac{1\\cdot 1/3}{1/2} = 2/3. \\] <p>This means that we should always change our selection after the host opens the door, as it will double our probability of success.</p>","tags":["SZD1 Homework"]},{"location":"szd1/doors.html#programming","title":"Programming","text":"<p>Task</p> <p>Write a short script that would simulate the three door problem for n times and based on the result verified our probability results. Use the prepared script bellow or write your own one.</p> Python <p>Finish the missing parts marked with <code>#TODO</code>.</p> <pre><code>import random\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pathlib\n\ndef main():\n    nIter = 1e3 # number of iterations\n\n    oldSelectionCorrect = []\n    newSelectionCorrect = []\n\n    for i in range(int(nIter)):\n        doors = [\"Door1\", \"Door2\", \"Door3\"]\n\n        # we randomly select one door as the correct door\n        correctDoor = None # TODO\n\n        # then we make our guess and also randomly pick one door\n        selectedDoor = None # TODO\n\n        # implement the opening of the one of the wrong doors\n        # TODO\n\n        # new selection would now be to pick the other unopened door\n        newSelection = None # TODO\n\n        # we save which decision would be better\n        # we save it in this weird way to get a nice plot with the number of iterations dependance\n        oldSelectionCorrect += [1] if correctDoor == selectedDoor else [0]\n        newSelectionCorrect += [1] if correctDoor == newSelection else [0]\n\n    print(f\"Number of iterations: {nIter}\")\n    print(f\"Original selection correct: {sum(oldSelectionCorrect)} ({sum(oldSelectionCorrect)/nIter:.3f} %)\")\n    print(f\"New selection correct: {sum(newSelectionCorrect)} ({sum(newSelectionCorrect)/nIter:.3f} %)\")\n\n    fName = plotTimeDevelopment(oldSelectionCorrect, newSelectionCorrect)\n    print(f\"Saved plot as {fName.resolve()}\")\n\ndef plotTimeDevelopment(oldSelectionCorrect, newSelectionCorrect):\n    # NO NEED TO ADJUST THIS FUNCTION\n    # calculate the cumulative sum\n    oldSelectionCorrect_cummulative = np.cumsum(oldSelectionCorrect)\n    newSelectionCorrect_cummulative = np.cumsum(newSelectionCorrect)\n\n    total = oldSelectionCorrect_cummulative + newSelectionCorrect_cummulative\n\n    fig, ax = plt.subplots()\n\n    x = np.arange(len(oldSelectionCorrect_cummulative))+1\n    ax.scatter(x, oldSelectionCorrect_cummulative / total, s=2, label = \"Old selection correct\")\n    ax.scatter(x, newSelectionCorrect_cummulative / total, s=2, label = \"New selection correct\")\n\n    ax.plot(x, oldSelectionCorrect_cummulative / total, alpha=.3)\n    ax.plot(x, newSelectionCorrect_cummulative / total, alpha=.3)\n\n    ax.plot([x[0], x[-1]], [1/3, 1/3], linestyle=\"--\", c=\"black\")\n    ax.plot([x[0], x[-1]], [2/3, 2/3], linestyle=\"--\", c=\"black\")\n\n    plt.ylabel(\"Success rate [%]\")\n    plt.xlabel(\"Number of iterations [-]\")\n\n    plt.legend()\n\n    ax.set_xscale(\"log\")\n\n    fName = pathlib.Path(\"dvere.png\")\n    fig.savefig(fName, dpi=250)\n    return fName\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Output <p>The output of the problem are the correction rates of the choices and a plot showing its dependance on the number of iterations.</p> <p></p> <p>Advanced</p> <p>Try to rewrite the code so that the <code>for</code> loop is avoided and the problem is solved via the vectorized approach.</p>","tags":["SZD1 Homework"]},{"location":"szd1/python_tutorial/analysis-visualisation-python.html","title":"Data Analysis and Visualization in Python","text":"<p>Python is a powerful tool nowadays used as industry standard for data science. It is also relatively easy to use. This tutorial is by no means an exhaustive set of usecases, its purpose is merely to demonstrate some of the many useful features of python and its libraries. In the following paragraphs we will learn how to load, process and visualise our data with some standard libraries like:</p> <ol> <li> <p>Numpy - Array (vectors, matrices, etc.) manipulation - addition, multiplication and other operations between arrays, applying functions to arrays and much more,</p> </li> <li> <p>Matplotlib - plotting and saving images of many kinds,</p> </li> <li> <p>Scipy - fitting, extremization of functions, statistics, etc.,</p> </li> <li> <p>Pandas - data input and output.</p> </li> </ol> <p>Sometimes when many files spread across several directories are used, Pathlib can be very useful for their management. The general structure of a python file will look the following way:</p>"},{"location":"szd1/python_tutorial/analysis-visualisation-python.html#loading-data-from-files","title":"Loading data from files","text":"<p>Depending on the complexity of our dataset, several approaches can be used. Rarely ever is the standard python open() function an optimal choice. When a simple csv file with only number inputs is to be loaded, numpy.genfromtxt() is a good option. It converts space separated data into a numpy array which can then be further manipulated. For larger datasets or more complex datatypes pandas offers several read-type functions (among which read_csv() is an option as well). Let's now try loading a simple shopping list.</p> <p><pre><code>import pandas as pd\n\n\n# Function definitions usually come first with the 'main()' function on top. For better readibility are individual functions separated by two spaces.\ndef main():\n\n    #load data\n    filename = 'novy_nakup.csv'\n    df = pd.read_csv(filename, sep = '\\t') #df stands for dataframe, 'sep' stands for separator of our values (tabulator in this case). For a complete list of arguments see the official documentation\n\n    #calculate the final price of our grocery list\n    sum = df['mnozstvi'] * df['cena_za_jednotku'] #this is a elementwise product of two arrays, basic opperations are implemented into the dataframe so no looping is required\n    sum = sum.sum() #python is dynamically typed so you can seamlesly change the sum variable from dataframe to a number. The sum, max, etc. methods are also implemented\n\n    #printing the grocery list and the total cost\n    print(df['polozka'].tolist(), sum) # the tolist() function converts dataframe to python array\n\n\n#this if statement is executed when the script is directly executed. When it is called inside a different script, it will not execute.\nif __name__ == \"__main__\":\n    main()\n</code></pre> As you can see all dependencies are imported at the beginning of the document, then function definitions are implemented and last comes the main body of the code (in this case the executing if statement). The output of the above code is the following:</p> Output <pre><code>['chleb', 'mleko', 'vejce', 'maslo', 'jablka', 'banany', 'rajcata', 'paprika', 'kureci', 'testoviny'] 1310\n</code></pre>"},{"location":"szd1/python_tutorial/analysis-visualisation-python.html#plotting-data","title":"Plotting data","text":"<p>Now let's try a larger dataset. For our toy data we can use e.g. the average temperature in the Czech Republic in the last ~45 years. Loading is the same as before</p> <pre><code>filename = 'weather_data.csv'\ndf = pd.read_csv(filename)\n</code></pre> <p>We can either check the csv file directly to see what are the column headers or we can call it in our program:</p> <pre><code>print(df.columns) #display column names. \n</code></pre> Output <pre><code>Index(['utc_timestamp', 'CZ_temperature'], dtype='object')\n</code></pre> <p>In pandas columns are called by their names, while the elements of a column are still indexed with numbers:</p> <p><pre><code>print(df[\"CZ_temperature\"][:10].tolist()) # the string calls the column, the [:10] calls the first 10 elements of that column. Any range (if it exists) n -&gt; m can be called with [n:m]\n</code></pre> The tolist() function converts the pandas dataframe into a python list.</p> Output <pre><code>[-3.422, -3.36, -3.429, -3.697, -4.081, -4.177, -4.192, -3.951, -2.905, -1.887]\n</code></pre> <p>In complete analogy we can print out the elements of the utc_timestamp column. Elements of this column are in the format YYYY-MM-DDThh-mm-ss.</p> <p>To plot our data we need to import a plotting library at the start of our script:</p> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <p>because pyplot does not know the time format, we need to convert it to datetime first, then we plot and display the figure on screen:</p> <pre><code>time = pd.to_datetime(df['utc_timestamp'])\nplt.plot(time, df['CZ_temperature'])\nplt.show()\n</code></pre> <p>The resulting image should look like this:</p> Output <p></p> <p>This image is quite raw, we should name the axes, change font size etc. All of this can be wrapped inside a function that can be recycled in the future:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\n\n\ndef main():\n    filename = 'weather_data.csv'\n    df = pd.read_csv(filename)\n    time = pd.to_datetime(df['utc_timestamp'])\n\n    ref_times = [\"1980-01-01\",\"1990-01-01\",\"2000-01-01\",\"2010-01-01\", \"2020-01-01\"] #create reference datetimes to showcase conditional operation on pandas dataframes\n\n    xdata = [time[(time &gt;= n) &amp; (time &lt; m)] for n, m in zip(ref_times[:-1], ref_times[1:])] # pandas allows conditional operation on its elements, in this case our time axis is split into 4 regions according to a decade time intervals\n    ydata = [df['CZ_temperature'][(time &gt;= n) &amp; (time &lt; m) ] for n, m in zip(ref_times[:-1], ref_times[1:])] # the temperature column is split with the same conditional mask\n    labels = ['yrs \\'80 - \\'90','yrs \\'90 - \\'00','yrs \\'00 - \\'10','yrs \\'10 - \\'20'] # label strings for the plot legend\n\n    simple_plot(xdata, ydata, labels, 'Date' ,'Temperature [$^\\\\circ$C]', 'temperature.png') #calling the plot function inside the main function\n\n\ndef simple_plot(xdata, ydata, labels, xlabel, ylabel, filename = None): #function for plotting several datasets into the same image, x and ydata are expected to be lists of arrays. If only a single dataset is to be plotted, it must also be inside a list -&gt; dataset = [dataset]\n\n    plt.rcParams['font.size'] = 14 # changes font size\n    fig, ax = plt.subplots(figsize = [8,6]) # creates a figure and a subplot object\n\n    for x, y, l in zip(xdata, ydata, labels): # loop over several arrays at once (cuts when the first array finishes)\n        ax.plot(x, y, label = l) # line plot of x and y with a label to displayed inside a legend\n\n    ax.legend() # includes a legend in the image\n    ax.set_xlabel(xlabel) # gives a name to the x axis, below analogy for y axis\n    ax.set_ylabel(ylabel) # matplotlib supports latex like math type-setting\n\n    plt.show() # displays the current figure \n    if filename:\n        fig.savefig(filename) # saves the figure 'fig' as a png file\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Several neat features of pandas dataframes were used and described in the code. An extended tutorial can be found in the official documentation. Running our script will result in this image</p> Output <p></p> <p>For more options on color, linestyles and much more check the official matplotlib documentation.</p>"},{"location":"szd1/python_tutorial/analysis-visualisation-python.html#data-analysis","title":"Data Analysis","text":"<p>Staying with our toy weather data and code we can show how simply it can be analysed with python. We of course notice that temperature in the Czech Republic changes periodically with the seasons. Let's find out what the period according to temperature is. For that we can run Fourier transform in a newly defined function and some libraries.</p> <pre><code>import numpy as np\nfrom scipy import fft, fftfreq\n</code></pre> <p><pre><code>def fourier(time, data):\n    yf = fft(data) # creates a complex array of fourier transformation, amplitude is in encoded in magnitude, phase is encoded in the angle of the complex number\n    xf = fftfreq(time.size) # creates sampling frequency array for further analysis and plotting\n\n    periods = 1 / xf / 24 # inverts the frequencies into periods\n    simple_plot([periods], [np.abs(yf)], ['fourier transform'], 'fft_temperature.png', 'Period [days]', 'Amplitude [arb.]')\n</code></pre> We can then call this function inside the main function. The code produces the following image.</p> Output <p></p> <p>There are two main frequencies - 365 days and 1 day - exactly as would be expected. Negative frequencies are important when dealing with complex data. Given that our data is strictly real we can ignore the negative part. </p> <p>Knowing the period we might try fitting the data with a sin function. For this we can use the function curve_fit from the scipy.optimize library. All we need to use it is to define our function for fitting which will depend on a single variable and several parameters to be determined. In this case we include:</p> <p><pre><code>from scipy.optimize import curve_fit\n</code></pre> and define</p> <pre><code>def sinx(x, amp, freq, phase, con):\n    return amp * np.sin(2 * np.pi * freq * x + phase) + con\n</code></pre> <p>To determine the parameters amp, freq, phase and con we use:</p> <p><pre><code>fit, pcov = curve_fit(sinx, xdata, ydata, p0 = [amp0, freq0, phase0, con0])\n</code></pre> where he p0 parameter is our initial guess. Because the temperature data is so noisy - we know that at least 2 frequencies are strongly present while we are only trying to fit one - the fit might be difficult to converge. When the algorithm converges it will produce a parameter fit array which we called fit and a covariance matrix called pcov the meaning of which will be discussed later in the lecture. To plot the fitting function we define a new array:</p> <p><pre><code>fit_values = sinx(xdata, *fit)\n</code></pre> where the * operator call the individual elements of our array as separate parameter inputs. </p> <p>Task</p> <p>Complete the code such that it produces the following image. Use our predefined plotting function.</p> Output <p></p> <p>This fit of course does not tell us much since the period was pretty much known from the Fourier transform and the amplitude varies significantly. Nevertheless fitting is a very powerful tool and it is important to know the method for future refference.</p>"},{"location":"szd1/python_tutorial/analysis-visualisation-python.html#histograms","title":"Histograms","text":"<p>Let's now leave the weather data behind and generate some of our own. Random number generation is also very important in statistics as we shall see in the near future. Much like many other things in python, generating a pseudorandom set of numbers is as easy as inluding a single line. We will now be working mostly with numpy</p> <pre><code>import numpy as np\n</code></pre> <p>Numpy includes many of the most used distributions like uniform, gaussian, etc. These can be generated as n-dimensional arrays. Let's start with a single dimension:</p> <pre><code>random_data1D = np.random.uniform(0, 1, 10000) # first and second value determine the limits of our interval, the final number is dataset size\n</code></pre> <p>A uniformly distributed set of values is expected populate intervals of the same size roughly equally. Let's check this fact visually in a histogram:</p> <p><pre><code>values, edges = np.histogram(random_data1D, bins = 100)\n</code></pre> The bins parameter can either take an integer value for the number of bins that will be created - minimum and maximum is determined from the dataset - or it can take an array of real values indicating the edges of our bins. We shall use this fact in a moment for a sum of histograms. For plotting a histogram we make use of the matplotlib.pyplot function stairs:</p> <pre><code>plt.stairs(values, edges, label)\n</code></pre> <p>which will produce an image similar to the following after stylizing it:</p> Output <p></p> <p>Task</p> <p>Wrap the stairs function in a similar fashion as our simple_plot function for future reference.</p> <p>How to check if a set of data is distributed according to some distribution will be done in a later part of the lecture. Now let's move over to higher dimensional histograms. We can start by generating 2 sets of random gaussian 2D data:</p> <pre><code>gaus1 = np.random.normal(6, 0.5, [2, 5000]) # generates 2 random sets of gaussian distributed values with mean value 4 and sigma 0.5 with size 5000\ngaus2 = np.random.normal(5, 0.3, [2, 1000])\n</code></pre> <p>To transform these sets to 2d histograms we use the numpy function histogram2d: <pre><code>hist1, xedges, yedges = np.histogram2d(*gaus1, bins = [20,20]) # generates a 2d histogram with 20 bins on each axis. The * operator has to be used to call both axes of our gaussian array\nhist2, xedges, yedges = np.histogram2d(*gaus2, bins = [xedges, yedges]) # this time instead of automatically producing the bin edges we use those edges created previously\n</code></pre> Now the variables hist1 and hist2 contains the number of values in each bin whose edges are defined in the variables x/yedges. Since both histograms have the same bin edges we can add the values of hist1 and hist2 together:</p> <pre><code>hist = hist1 + hist2\n</code></pre> <p>For plotting we again define a custom function:</p> <pre><code>def plot_histogram2d(hist, xedges, yedges, xlabel, ylabel, filename = None):\n    plt.rcParams['font.size'] = 14\n    fig, ax = plt.subplots(figsize = [8,6])\n    hist_fig = ax.imshow(hist, extent = [xedges[0], xedges[-1], yedges[0], yedges[-1]])\n    fig.colorbar(hist_fig)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    plt.show()\n    if filename:\n        fig.savefig(filename)\n</code></pre> <p>and we call it in the main function</p> <pre><code>plot_histogram2d(hist, xedges, yedges, 'x label', 'y label', '2d_histogram.png')\n</code></pre> <p>A result may look like this:</p> Output <p></p>"},{"location":"szd1/python_tutorial/analysis-visualisation-python.html#conclusion","title":"Conclusion","text":"<p>It was hopefully demonstrated that data analysis and visualisation is quite simple yet effective with use of the right python libraries. Of course all of those showcased here are much more extensive than can be covered in such a short tutorial. Whenever you get to analyse your data I sincerely recommend checking the documentation of these libraries (or just google) if a solution to your problem has not already been implemented.</p>"},{"location":"szd2/index.html","title":"SZD2","text":""},{"location":"szd2/geant/geant-install.html","title":"Geant4 instalace pomoc\u00ed Anaconda","text":""},{"location":"szd2/geant/geant-install.html#instalace-pro-python","title":"Instalace pro Python","text":"<p>Pro instalaci pou\u017eijeme Anacondu, co\u017e je package a environment manager pro Python. Jedn\u00e1 se o jednu z ofici\u00e1ln\u011b doporu\u010den\u00fdch instalac\u00ed Geant4. P\u0159\u00ed lok\u00e1ln\u00ed instalaci t\u00edmto zp\u016fsobem p\u016fjde kompilovat i C++ verze Geantu.</p> <p>P\u0159\u00edprava Geant4 pro Python je pops\u00e1na v n\u00e1sleduj\u00edc\u00edch kroc\u00edch.</p> <p>Note</p> <p>Pro instalaci je dobr\u00e9 m\u00edt otev\u0159en\u00fd nov\u00fd termin\u00e1l, ve kter\u00e9m nejsou setupovan\u00e1 \u017e\u00e1dn\u00e1 prost\u0159ed\u00ed.</p>"},{"location":"szd2/geant/geant-install.html#1-instalace-anacondy","title":"1. Instalace Anacondy","text":"<p>V prvn\u00edm kroku je pot\u0159eba nainstalovat Anacondu z ofici\u00e1ln\u00edch str\u00e1nek. Nejjednodu\u0161\u0161\u00ed je instalace z p\u0159\u00edkazov\u00e9ho \u0159\u00e1dku. </p> <p>Warning</p> <p>P\u0159i instalaci z p\u0159\u00edkazov\u00e9ho \u0159\u00e1dku je pot\u0159eba spustit oba sety p\u0159\u00edkaz\u016f, tedy i ten, kter\u00fd obsahuje <code>init</code>.  </p> <p>Anaconda automaticky updatuje v\u00e1\u0161 <code>~/.bashrc</code>, co\u017e znamen\u00e1, \u017ee se Anaconda inicializuje p\u0159i ka\u017ed\u00e9m nov\u00e9m otev\u0159en\u00ed termin\u00e1lu. Pokud toto chov\u00e1n\u00ed nechcete, je pot\u0159eba setup Anacondy z <code>~/.bashrc</code> vymazat a p\u0159esunout do samostatn\u00e9ho setup souboru, kter\u00fd budete pou\u017e\u00edvat pro setup Anacondy. Zmi\u0148ovan\u00fd \u00fasek je n\u00e1sleduj\u00edc\u00ed (se zm\u011bnou cesty na tu va\u0161i):</p> ~/.bashrc<pre><code>...\n# &gt;&gt;&gt; conda initialize &gt;&gt;&gt;\n# !! Contents within this block are managed by 'conda init' !!\n__conda_setup=\"$('/home/&lt;you&gt;/miniconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)\"\nif [ $? -eq 0 ]; then\n    eval \"$__conda_setup\"\nelse\n    if [ -f \"/home/&lt;you&gt;/miniconda3/etc/profile.d/conda.sh\" ]; then\n        . \"/home/&lt;you&gt;/miniconda3/etc/profile.d/conda.sh\"\n    else\n        export PATH=\"/home/&lt;you&gt;/miniconda3/bin:$PATH\"\n    fi\nfi\nunset __conda_setup\n# &lt;&lt;&lt; conda initialize &lt;&lt;&lt;\n...\n</code></pre> <p>Pro ov\u011b\u0159en\u00ed, \u017ee v\u0161e funguje, jak m\u00e1, je pot\u0159eba zav\u0159\u00edt a znovu otev\u0159\u00edt termin\u00e1l. Pokud jste setup ponechali v <code>~/.bashrc</code>, m\u011blo by se vedle va\u0161eho jm\u00e9no objevit <code>(base)</code>, co\u017e zn\u00e1zor\u0148uje z\u00e1kladn\u00ed Anaconda prost\u0159ed\u00ed. Pokud jste setup p\u0159esunuli do jin\u00e9ho souboru, je pot\u0159eba tento skript nejd\u0159\u00edve spustit. </p> <p></p>"},{"location":"szd2/geant/geant-install.html#2-instalace-geant4-pomoci-anacondy","title":"2. Instalace Geant4 pomoc\u00ed Anacondy","text":"<p>Instalace Geant4 pomoc\u00ed Anacondy je pops\u00e1na v ofici\u00e1ln\u00edm instala\u010dn\u00edm n\u00e1vodu Geant4. Pokud byla Anaconda spr\u00e1vn\u011b nainstalov\u00e1na, sta\u010d\u00ed spustit n\u00e1sleduj\u00edc\u00ed p\u0159\u00edkazy</p> <pre><code>conda create -c conda-forge --name geant4 geant4 #(1)!\nconda activate geant4 #(2)!\n</code></pre> <ol> <li>Vytvo\u0159\u00ed prost\u0159ed\u00ed s n\u00e1zvem <code>geant4</code> na nainstaluje do n\u011bj Geant4.</li> <li>Aktivuje prost\u0159ed\u00ed s n\u00e1zvem <code>geant4</code>.</li> </ol> <p>Inicializace prost\u0159ed\u00ed pomoc\u00ed druh\u00e9ho p\u0159\u00edkazu je nutn\u00e1 v\u017edy po otev\u0159en\u00ed nov\u00e9ho termin\u00e1lu. </p> <p>Po aktivace se zm\u011bn\u00ed text v z\u00e1vorce vedle va\u0161eho jm\u00e9na v termin\u00e1lu z <code>(base)</code> na <code>(geant4)</code>: </p>"},{"location":"szd2/geant/geant-install.html#3-instalace-knihovny-geant4-pro-python","title":"3. Instalace knihovny Geant4 pro python","text":"<p>Warning</p> <p>V tomto kroku mus\u00ed b\u00fdt nastaven\u00e9 prost\u0159ed\u00ed <code>geant4</code> vytvo\u0159en\u00e9 v p\u0159edchoz\u00edm kroku. Aktivace prob\u00edh\u00e1 p\u0159\u00edkazem  <pre><code>conda activate geant4\n</code></pre> Po aktivaci bude v termin\u00e1lu nalevo od va\u0161eho jm\u00e9na <code>(geant4)</code>. </p> <p>Instalace Geant4 knihovny pro Python prob\u00edh\u00e1 spu\u0161t\u011bn\u00edm n\u00e1sleduj\u00edc\u00edho p\u0159\u00edkazu</p> <pre><code>pip install geant4-pybind\n</code></pre> <p>Spr\u00e1vnost instalace si lze ov\u011b\u0159it zapnut\u00edm pythonu (p\u0159\u00edkaz <code>python</code>) a n\u00e1sledn\u011b uvnit\u0159 Pythonu p\u0159\u00edkazem </p> <pre><code>import geant4_pybind\n</code></pre> <p>Pokud se nevyp\u00ed\u0161e \u017e\u00e1dn\u00fd error, setup prob\u011bhl \u00fasp\u011b\u0161n\u011b. </p>"},{"location":"szd2/geant/geant4.html","title":"Geant4","text":"<p>Geant4 is a powerful, open-source simulation toolkit used to model the interaction of particles with matter. It's widely used in various fields, including:</p> <ul> <li>High-Energy Physics: Simulating particle collisions, detector responses, and data analysis.</li> <li>Nuclear Physics: Studying nuclear reactions, radiation transport, and detector simulations.</li> <li>Medical Physics: Modeling radiation therapy, dosimetry, and medical imaging.</li> <li>Space Exploration: Simulating radiation effects on spacecraft, astronauts, and electronic components.</li> <li>Materials Science: Investigating radiation damage, radiation-induced effects, and materials properties.</li> </ul> <p>Geant4 provides a comprehensive framework for simulating the transport of particles, such as electrons, photons, neutrons, and ions, through various materials and detectors. It takes into account complex physical processes, including:</p> <ul> <li>Ionization and excitation</li> <li>Bremsstrahlung and pair production</li> <li>Compton scattering and photoelectric effects</li> <li>Hadronic interactions and nuclear reactions</li> </ul> <p>The toolkit allows the user to define:</p> <ul> <li>Interaction physics</li> <li>Geometry and composition of the matter (detector)</li> <li>Particle generation</li> <li>Data readout</li> <li>Vizualisation</li> </ul> <p>Geant4 is written in C++ and provides a flexible, modular architecture, allowing users to customize and extend the toolkit to suit their specific needs. There is also a possibility to use Geant4 with Python.</p> <p>Info</p> <p>Basic understanding of the framework can be obtained by following this youtube playlist. </p>"},{"location":"szd2/geant/geant4.html#installation-setup","title":"Installation &amp; setup","text":"<p>The instruction for a local installation one needs to follow the dedicated official documentation. Information about local installation via Anaconda are provided here.</p> <p>On sunrise machine, Geant4 can be set up by running the following command</p> C++Python <pre><code>source /data2/vyuka/szd/G4_setup.sh\n</code></pre> <pre><code>source /data2/vyuka/szd/setup_Geant4.sh\n</code></pre>"},{"location":"szd2/geant/geant4.html#simulation-setup","title":"Simulation setup","text":"<p>There are three components that need to be prepared for each simulation:</p> <ul> <li> <p>Construction definition</p> <p>Definition of the geometry and material of the detector or general volume, that we want to simulate. </p> <p> More</p> </li> <li> <p>Physics list</p> <p>Definition of the actual physics that will be active during the simulation. </p> <p>This is mainly for speed purposes: for example during simulation of electrons in electromagnetic calorimeters, no hadronic processes are needed so we can turn them off and speed up the simulation.</p> <p> More</p> </li> <li> <p>Action definition</p> <p>Definition of various action performed during the simulations: generation of particles, detection of particles, tracking and stepping.</p> <p> More</p> </li> </ul> <p></p> C++Python <p>In <code>C++</code>, each part needs to be writted as a separate class, for clarity purposes with its own header and definition file. The typical file structure is therefore</p> <pre><code>mainFile.cc\nCMakeLists.txt\ninclude/\n    construction.hh\n    physicsList.hh\n    action.hh\nsrc/\n    construction.cc\n    physicsList.cc\n    action.cc\n</code></pre> <p>The structure of the main file is explained later. </p> <p>The <code>CMakeLists.txt</code> is required for proper compilation of the multiple files. For details, refer to Running the simulation.</p> <p>In <code>Python</code>, each part needs to be writtes as a separate class. However, thanks to simplicity of <code>Python</code>, it is recommanded to keep everything in one file, unless the project is very complicated. </p>"},{"location":"szd2/geant/geant4.html#main-file","title":"Main file","text":"<p>In the main file, we tell Geant what files we want to use to define the individual parts of the simulation, start the GUI and apply basic commands. </p> C++Python mainFile.cc<pre><code>#include \"iostream\"\n\n// We import the Geant stuff\n#include \"G4RunManager.hh\"\n#include \"G4UIExecutive.hh\"\n#include \"G4VisExecutive.hh\"\n#include \"G4VisManager.hh\"\n#include \"G4UImanager.hh\"\n\n// We import our header files for construction, physics list and action\n#include \"include/construction.hh\"\n#include \"include/physicsList.hh\"\n#include \"include/action.hh\"\n\nint main(int argc, char** argv){\n    // We initialise the Geant4 manager\n    auto *runManager = new G4RunManager();\n\n    // We tell Geant what construction, physics list and action to use\n    // these classes are defined in the imported header files\n    runManager-&gt;SetUserInitialization(new ConstructionDefinition());\n    runManager-&gt;SetUserInitialization(new PhysicsListDefinition());\n    runManager-&gt;SetUserInitialization(new ActionDefinition());\n\n    // We initialise the Geant4 manager\n    runManager-&gt;Initialize();\n\n    // We prepare and initialise the GUI\n    auto *ui = new G4UIExecutive(argc, argv);\n    auto *visManager = new G4VisExecutive();\n    visManager-&gt;Initialize();\n\n    // We can send commands (e.g. create particles) from \n    // the GUI or from here already using the UImanager\n    G4UImanager *UImanager =  G4UImanager::GetUIpointer();\n    // Commands are applied like this: \n    // this one tells the UI to run 10 particles\n    UImanager-&gt;ApplyCommand(\"/run/beamOn 10\");\n\n    // Finally we start the session\n    ui-&gt;SessionStart();\n\n    return 0;\n}\n</code></pre> mainFile.py<pre><code># We import Geant4\nfrom geant4_pybind import *\n\n# We either import the required classes (construction, physics list, action) \n# from separate definition files or define them here above the main funciton\n\ndef main(electronEnergy, foilWidth, fPath, nParticles):\n    # We initialise the Geant4 manager\n    runManager = G4RunManagerFactory.CreateRunManager(G4RunManagerType.Serial)\n\n    # We tell Geant what construction, physics list and action to use\n    # These classes need to be defined by us\n    runManager.SetUserInitialization(ConstructionDefinition())\n    runManager.SetUserInitialization(PhysicsListDefinition())\n    runManager.SetUserInitialization(ActionDefinition())\n\n    # We initialise the Geant4 manage\n    runManager.Initialize()\n\n    # We prepare and initialise the GUI\n    ui = G4UIExecutive()\n    visManager = G4VisExecutive()\n    visManager.Initialize()\n\n    # We can send commands (e.g. create particles) from \n    # the GUI or from here already using the UImanager\n    UImanager = G4UImanager.GetUIpointer()\n\n    # Commands are applied like this: \n    # this one tells the UI to run 10 particles\n    UImanager.ApplyCommand(f\"/run/beamOn {int(nParticles)}\")\n\n    # Finally we start the session\n    ui.SessionStart()\n\n# This will automatically call the main function \n# when we write `python mainFile.py` to the terminal\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"szd2/geant/geant4.html#construction-definition","title":"Construction definition","text":"<p>Detector / volume construction is performed in three steps:</p> <ul> <li>Solid volume - definition of shape and proportions</li> <li>Logical volume - definition of the material</li> <li>Physical volume - setting the volume in space</li> </ul> <p>The implementation is performed via the <code>G4VUserDetectorConstruction</code> class.</p> <p>For demonstration, we create a golden plate in a vacuum. First we create the \"vacuum box\":</p> <p>Info</p> <p>In general, the top volume is called the the world volume. In this example, the world volume consists of vacuum, but this is arbitrary.</p> C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction { // (1)!\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); // (2)!\n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> <ol> <li>We derive our class from the <code>G4VUserDetectorConstruction</code> class.</li> <li>This is the actual method that we will use in the <code>src/construction.cc</code> to construct the volume (see bellow).</li> </ol> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n\n// We include the header file\n#include \"../include/construction.hh\" // (1)!\n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; // (7)!\n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); // (2)!\n\n    // VACUUM BOX CONSTRUCTION\n    auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); // (3)!\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, worldMaterial, \"World\"); // (5)!\n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  // (6)!\n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n}\n</code></pre> <ol> <li>This header file must include the definition of the classes that are implemented in this file.   </li> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length. List of other shapes.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it. The last argument is the (arbitrary) name.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>#include &lt;G4SystemOfUnits.hh&gt;</code> we can use the standard units (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm # (6)!\n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() # (1)!\n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") # (2)!\n\n        # VACUUM BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) # (3)!\n        logicWorld = G4LogicalVolume(solidWorld, world_material, name=\"World\") # (4)!\n\n        physWorld = G4PVPlacement(None,  # (5)!\n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n</code></pre> <ol> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>from geant4_pybind import *</code> we also imported the units namelist from Geant4 and therefore we can use the standard units like this (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> </ol> <p>Similarly, we can implement the golden foil itself: we need to use different dimension, different material, and we want to place the foil inside the vacuum box  we select the vacuum box as the parent volume. We continue in the <code>Construct</code> method:</p> C++Python src/construction.cc<pre><code>...\n// The construction method that we worked with\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // Implementation of the vacuum box from above\n    ...\n\n    // After that, we want to add the golden foil\n    auto *foilMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Au\");\n    auto *solidFoil = new G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ);\n    auto *logicFoil = new G4LogicalVolume(solidFoil, foilMaterial, \"Foil\");\n\n    G4VPhysicalVolume *physFoilVolume = new G4PVPlacement(nullptr,                  // no rotation\n                                                        G4ThreeVector(0., 0., 0.),  // position in the center\n                                                        logicFoil,                  // corresponding logical volume\n                                                        \"Foil\",                     // name\n                                                        logicWorld,                 // parent volume\n                                                        false,                      // no multiples\n                                                        0,                          // no copies\n                                                        true);                      // check for overlaps\n                                                        //(1)! \n}\n</code></pre> <ol> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # Implementation of the vacuum box from above\n        ...\n\n        # After that, we want to add the golden foil\n        foil_material = nist.FindOrBuildMaterial(\"G4_Au\")\n        solidFoil = G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ)\n        logicFoil = G4LogicalVolume(solidFoil, foil_material, name=\"Foil\")\n        physFoil = G4PVPlacement(None,              # no rotation\n                                G4ThreeVector(),    # position in the center\n                                logicFoil,          # corresponding logical volume\n                                \"Foil\",             # name\n                                logicWorld,         # parent volume \n                                True,               # no multiples\n                                0,                  # no copies\n                                True)               # check for overlaps\n                                # (1)! \n</code></pre> <ol> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> Full example C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction { // (1)!\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); // (2)!\n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> <ol> <li>We derive our class from the <code>G4VUserDetectorConstruction</code> class.</li> <li>This is the actual method that we will use in the <code>src/construction.cc</code> to construct the volume (see bellow).</li> </ol> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n\n// We include the header file\n#include \"../include/construction.hh\" // (1)!\n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; // (7)!\n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); // (2)!\n\n    // VACUUM BOX CONSTRUCTION\n    auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); // (3)!\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, worldMaterial, \"World\"); // (5)!\n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  // (6)!\n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n\n    // After that, we want to add the golden foil\n    auto *foilMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Au\");\n    auto *solidFoil = new G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ);\n    auto *logicFoil = new G4LogicalVolume(solidFoil, foilMaterial, \"Foil\");\n\n    G4VPhysicalVolume *physFoilVolume = new G4PVPlacement(nullptr,                  // no rotation\n                                                        G4ThreeVector(0., 0., 0.),  // position in the center\n                                                        logicFoil,                  // corresponding logical volume\n                                                        \"Foil\",                     // name\n                                                        logicWorld,                 // parent volume\n                                                        false,                      // no multiples\n                                                        0,                          // no copies\n                                                        true);                      // check for overlaps\n                                                        //(8)! \n}\n</code></pre> <ol> <li>This header file must include the definition of the classes that are implemented in this file.   </li> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it. The last argument is the (arbitrary) name.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: </li> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> <li>Thanks to <code>#include &lt;G4SystemOfUnits.hh&gt;</code> we can use the standard units (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm # (6)!\n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() # (1)!\n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") # (2)!\n\n        # VACUUM BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) # (3)!\n        logicWorld = G4LogicalVolume(solidWorld, world_material, name=\"World\") # (4)!\n\n        physWorld = G4PVPlacement(None,  # (5)!\n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n\n        # After that, we want to add the golden foil\n        foil_material = nist.FindOrBuildMaterial(\"G4_Au\")\n        solidFoil = G4Box(\"Foil\", 0.5 * foil_sizeXY, 0.5 * foil_sizeXY, 0.5 * foil_sizeZ)\n        logicFoil = G4LogicalVolume(solidFoil, foil_material, name=\"Foil\")\n        physFoil = G4PVPlacement(None,              # no rotation\n                                G4ThreeVector(),    # position in the center\n                                logicFoil,          # corresponding logical volume\n                                \"Foil\",             # name\n                                logicWorld,         # parent volume \n                                True,               # no multiples\n                                0,                  # no copies\n                                True)               # check for overlaps\n                                # (7)! \n</code></pre> <ol> <li>There is a list of predefined materials that we can use. Alternatively, we can define the material ourselves.</li> <li>There is not exactly vacuum in Geant4, so we select the material with the lowest density instead. The list of possible materials is here.</li> <li>This is the solid volume definition step: it defines the dimensions of the material. The parameters are: name, X length, Y length, Z length. List of other shapes.</li> <li>Here we take the solid volume defined on the previous line and assign the material to it.</li> <li>Finally, we place the volume as the physical volume. The arguments are following: <ol> <li>rotation of the volume (we do not want to rotate that)</li> <li>position in space (no need to overthink, we put it in the center),</li> <li>the logic volume that we want to use (the one we defined on previous line),</li> <li>the name of the volume,</li> <li>parent volume (this is the top volume, so there is no parent volume),</li> <li>bool options if we want to add multiple instances of this volume (we don't want that here),</li> <li>number of copies (again, we do not want that here),</li> <li>bool option for volume check: checks overlaps of volumes, which may cause problems in the simulations (we almost always want this on).</li> </ol> </li> <li>Thanks to <code>from geant4_pybind import *</code> we also imported the units namelist from Geant4 and therefore we can use the standard units like this (it just effectively multiplies it by the appropriate factor to match the base units Geant4 works with).</li> <li>Note that we use the <code>logicWorld</code> (vacuum box defined above) as the parent volume.</li> </ol> <p>Info</p> <p>Apart from the box that we have used, there are also other shapes (sphere, cone, ...), see the list of shapes.</p>"},{"location":"szd2/geant/geant4.html#definition-of-custom-material","title":"Definition of custom material","text":"<p>All elements are predefined in Geant4, the list of them can be found here. However, sometimes we need to create a compound from different elements. </p> <p>For this we define our own material via the <code>G4Material</code> class. We define the density of the material and number of components, which we will add.</p> C++Python <pre><code>#include \"G4Material.hh\"\n#include \"G4Element.hh\"\n#include \"G4NistManager.hh\"\n\n// Get the predefined elements that our material comprises of\nG4Element* C = G4NistManager::Instance()-&gt;FindOrBuildElement(\"C\");\nG4Element* O = G4NistManager::Instance()-&gt;FindOrBuildElement(\"O\");\nG4Element* N = G4NistManager::Instance()-&gt;FindOrBuildElement(\"N\");\n\n// Define the material\nG4Material* MyMaterial = new G4Material(\"MyMaterial\", 1.2*g/cm3, 3); // name of the material, density, number of elements\nMyMaterial-&gt;AddElement(C, 0.5); // 50% Carbon by weight\nMyMaterial-&gt;AddElement(O, 0.3); // 30% Oxygen by weight\nMyMaterial-&gt;AddElement(N, 0.2); // 20% Nitrogen by weight\n</code></pre> <pre><code>from geant4_pybind import *\n\n# Get the predefined elements that our material comprises of\nC = G4Element.GetElement(\"C\")\nO = G4Element.GetElement(\"O\")\nN = G4Element.GetElement(\"N\")\n\n# Define the material\nMyMaterial = G4Material(\"MyMaterial\", 1.2*g/cm3, 3) # name of the material, density, number of elements\nMyMaterial.AddElement(C, 0.5)  # 50% Carbon by weight\nMyMaterial.AddElement(O, 0.3)  # 30% Oxygen by weight\nMyMaterial.AddElement(N, 0.2)  # 20% Nitrogen by weight\n</code></pre> <p>Info</p> <p>The material definition would be performed inside the <code>Construct</code> method in the <code>G4VUserDetectorConstruction</code> that we work with. </p> <p>In other words, replace the line with <code>FindOrBuildMaterial</code> in the codes here by the lines above. </p> Full example C++Python include/construction.hh<pre><code>#ifndef DETECTORCONSTRUCTION_HH\n#define DETECTORCONSTRUCTION_HH\n\n#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VPhysicalVolume.hh\"\n\n\nclass DetectorConstruction : public G4VUserDetectorConstruction {\npublic:\n    DetectorConstruction();\n    ~DetectorConstruction();\n\n    G4VPhysicalVolume *Construct(); \n};\n\n\n#endif //DETECTORCONSTRUCTION_HH\n</code></pre> src/construction.cc<pre><code>// Geant4 includes\n#include &lt;G4Box.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n#include &lt;G4NistManager.hh&gt;\n#include &lt;G4LogicalVolume.hh&gt;\n#include &lt;G4PVPlacement.hh&gt;\n#include &lt;G4VPhysicalVolume.hh&gt;\n#include &lt;G4Material.hh&gt;\n#include \"G4Element.hh\"\n\n// We include the header file\n#include \"../include/construction.hh\" \n\n// Simple constructor and destructor\nDetectorConstruction::DetectorConstruction(){};\nDetectorConstruction::~DetectorConstruction(){};\n\n// Construction method itself\nG4VPhysicalVolume *DetectorConstruction::Construct() {\n    // We define the foil size and the world size\n    double foil_sizeXY = 1. * cm; \n    double foil_sizeZ = 1000. * um;\n\n    double world_sizeXY = foil_sizeXY * 1.2;\n    double world_sizeZ = foil_sizeZ * 2 + 1*cm;\n\n    // We create an instance of the material manager\n    G4NistManager *nist = G4NistManager::Instance(); \n\n    // BOX CONSTRUCTION\n    // (1)!\n    // auto worldMaterial = nist-&gt;FindOrBuildMaterial(\"G4_Galactic\"); \n\n    // Get the predefined elements that our material comprises of\n    G4Element* C = G4NistManager::Instance()-&gt;FindOrBuildElement(\"C\");\n    G4Element* O = G4NistManager::Instance()-&gt;FindOrBuildElement(\"O\");\n    G4Element* N = G4NistManager::Instance()-&gt;FindOrBuildElement(\"N\");\n\n    // Define the material\n    G4Material* MyMaterial = new G4Material(\"MyMaterial\", 1.2*g/cm3, 3); // name of the material, density, number of elements\n    MyMaterial-&gt;AddElement(C, 0.5); // 50% Carbon by weight\n    MyMaterial-&gt;AddElement(O, 0.3); // 30% Oxygen by weight\n    MyMaterial-&gt;AddElement(N, 0.2); // 20% Nitrogen by weight\n\n    auto *solidWorld = new G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 *world_sizeZ); // (4)!\n    auto *logicWorld = new G4LogicalVolume(solidWorld, MyMaterial, \"World\"); \n\n    G4VPhysicalVolume *physWorldVolume = new G4PVPlacement(nullptr,  \n                                                        G4ThreeVector(0., 0., 0.),\n                                                        logicWorld,\n                                                        \"World\",\n                                                        nullptr,\n                                                        false,\n                                                        0,\n                                                        true\n    );\n}\n</code></pre> <ol> <li>This is what we used before in the main file. We replace it by our own material.</li> </ol> mainFile.py or construction.py<pre><code>from geant4_pybind import *\n\nclass Construction(G4VUserDetectorConstruction):\n    def Construct(self):\n        # We define the foil size and the world size\n        foil_sizeXY = 1 * cm \n        foil_sizeZ = 1000 * um\n\n        world_sizeXY = foil_sizeXY * 1.2\n        world_sizeZ = foil_sizeZ * 2 + 1 * cm\n\n        # We create an instance of the material manager\n        nist = G4NistManager.Instance() \n\n        # Can't select vacuum as it hase density 0 -&gt; G4_Galactic has very low density\n        # (1)!\n        # world_material = nist.FindOrBuildMaterial(\"G4_Galactic\") \n\n        # Get the predefined elements that our material comprises of\n        C = G4Element.GetElement(\"C\")\n        O = G4Element.GetElement(\"O\")\n        N = G4Element.GetElement(\"N\")\n\n        # Define the material\n        MyMaterial = G4Material(\"MyMaterial\", 1.2*g/cm3, 3) # name of the material, density, number of elements\n        MyMaterial.AddElement(C, 0.5)  # 50% Carbon by weight\n        MyMaterial.AddElement(O, 0.3)  # 30% Oxygen by weight\n        MyMaterial.AddElement(N, 0.2)  # 20% Nitrogen by weight\n\n        # BOX CONSTRUCTION\n        solidWorld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ) \n        logicWorld = G4LogicalVolume(solidWorld, MyMaterial, name=\"World\") \n\n        physWorld = G4PVPlacement(None,  \n                                G4ThreeVector(),  \n                                logicWorld,  \n                                \"World\", \n                                None,  \n                                False,  \n                                0,  \n                                True)  \n</code></pre> <ol> <li>This is what we used before in the main file. We replace it by our own material.</li> </ol> <p>For advanced, the <code>G4Element</code> can be defined by us: this can be useful when we want to use specific isotopic composition. See the example bellow, where we want to create LiH with two different isotopes of lithium.</p> C++Python <pre><code>G4Material *LiH = new G4Material(\"LiH\", 0.78*g/cm3, 2); // name, density\nG4Isotope *Li7 = new G4Isotope(\"Li7\", 3, 7); // name, atomic number Z, nucleon number N\nG4Isotope *Li6 = new G4Isotope(\"Li6\", 3, 6); // name, atomic number Z, nucleon number N\nG4Element *Li = new G4Element(\"Li\", \"Li\", 2); // name, symbol, number of isotopes\n\n// We add the isotopes to Li\nLi-&gt;AddIsotope(Li7, 5*perCent); // what isotope we add, its percentage\nLi-&gt;AddIsotope(Li6, 95*perCent); // what isotope we add, its percentage\n\n// Finaly we make the LiH: which means adding 1 atom of Li and 1 atom of H\nLiH-&gt;AddElement(Li, 1); // element we are adding, number of atoms\nLiH-&gt;AddElement(nist-&gt;FindOrBuildElement(\"H\"), 1); // element we are adding, number of atoms\n</code></pre> <pre><code>LiH = G4Material(\"LiH\", 0.78*g/cm3, 2) # name, density\nLi7 = G4Isotope(\"Li7\", 3, 7)  # name, atomic number Z, nucleon number N\nLi6 = G4Isotope(\"Li6\", 3, 6)  # name, atomic number Z, nucleon number N\nLi = G4Element(\"Li\", \"Li\", 2) # name, symbol, number of isotopes\n\n# We add the isotopes to Li\nLi.AddIsotope(Li7, 5*perCent) # what isotope we add, its percentage\nLi.AddIsotope(Li6, 95*perCent) # what isotope we add, its percentage\n\n# Finaly we make the LiH: which means adding 1 atom of Li and 1 atom of H\nLiH.AddElement(Li, 1) # element we are adding, number of atoms\nLiH.AddElement(nist.FindOrBuildElement(\"H\"), 1) # element we are adding, number of atoms\n</code></pre>"},{"location":"szd2/geant/geant4.html#physics-list-definition","title":"Physics list definition","text":"<p>One could either define own physics list or use a predefined one. </p>"},{"location":"szd2/geant/geant4.html#using-predefined-physics-list","title":"Using predefined physics list","text":"<p>To use a predefined physics list, we need to create an instance of that physics list in the main file and set in using the <code>SetUserInitialization</code> method. In this case, we no longer need the <code>physicsList.hh</code> and <code>physicsList.cc</code> files. </p> C++Python mainFile.cc<pre><code>#include \"QBBC.hh\"\n// other includes\n// (1)!\nint main(int argc, char** argv){\n    ...\n    G4VModularPhysicsList *physicsList = new QBBC; // QGSC + BinaryCascade + Bertini + CHIPS\n    //physicsList-&gt;RegisterPhysics (new G4OpticalPhysics()); // Cv. part one\n    runManager-&gt;SetUserInitialization(physicsList); // adds physics list\n    ...\n}\n</code></pre> <ol> <li>This is the main file presented in the Main file section.</li> </ol> mainFile.py<pre><code>from geant4_pybind import *\n# (1!\ndef main():\n    ...\n    runManager.SetUserInitialization(QBBC()) # QGSC + BinaryCascade + Bertini + CHIPS\n    ...\n</code></pre> <ol> <li>This is the main file presented in the Main file section.</li> </ol> <p>In other words, there is only change in the main file depending on what predefined physics list we choose.</p> <p>Info</p> <p>Find the list of predefined physics list here.</p>"},{"location":"szd2/geant/geant4.html#using-own-physics-list","title":"Using own physics list","text":"<p>To define own physics list, we will use the <code>G4VModularPhysicsList</code> class.</p> C++Python include/physicsList.hh<pre><code>#ifndef PHYSICSLIST_HH\n#define PHYSICSLIST_HH\n\n#include &lt;G4VModularPhysicsList.hh&gt;\n\nclass PhysicsList : public G4VModularPhysicsList{\npublic:\n    PhysicsList();\n    ~PhysicsList();\n};\n\n#endif //PHYSICSLIST_HH\n</code></pre> src/physicsList.cc<pre><code>#include &lt;G4EmStandardPhysics.hh&gt;\n#include &lt;G4DecayPhysics.hh&gt;\n#include &lt;G4EmLowEPPhysics.hh&gt;\n\n#include \"../include/physicsList.hh\"\n\nPhysicsList::PhysicsList() {\n    RegisterPhysics (new G4EmStandardPhysics());\n    RegisterPhysics (new G4EmLowEPPhysics());\n    RegisterPhysics(new G4DecayPhysics());\n}\n\nPhysicsList::~PhysicsList() {};\n</code></pre> mainFile.py or physicsList.py<pre><code>from geant4_pybind import *\n\n    class PhysicsList(G4VModularPhysicsList):\n\n    def __init__(self):\n        super().__init__()\n\n        # Default physics\n        self.RegisterPhysics(G4DecayPhysics())\n\n        # EM physics\n        self.RegisterPhysics(G4EmStandardPhysics())\n\n        # Decay physics\n        self.RegisterPhysics(G4DecayPhysics())\n</code></pre> <p>Note that the <code>mainFile.cc</code> of <code>mainFile.py</code> would be exactly same as here in this case. </p>"},{"location":"szd2/geant/geant4.html#action-definition","title":"Action definition","text":"<p>The action class allows us to define, among others, particle definition and particle detection. </p> <p>We will inherit from <code>G4VUserActionInitialization</code> class for our action class.</p> C++Python include/action.hh<pre><code>#ifndef ACTION_HH\n#define ACTION_HH\n\n#include &lt;G4VUserActionInitialization.hh&gt;\n\nclass ActionInitialization : public G4VUserActionInitialization {\npublic:\n    ActionInitialization();\n    ~ActionInitialization();\n    virtual void Build() const; // this is the method that we will work with\n};\n\n\n#endif //ACTION_HH\n</code></pre> src/action.cc<pre><code>#include \"../include/action.hh\"\n\nActionInitialization::ActionInitialization() = default;\n\nActionInitialization::~ActionInitialization() = default;\n\nvoid ActionInitialization::Build() const {\n    // we will add our actions here\n\n}\n</code></pre> mainFile.py or action.py<pre><code>from geant4_pybind import *\n\nclass ActionInitialization(G4VUserActionInitialization):\n    def Build(self):\n        # we will add our actions here\n        pass\n</code></pre> <p>Now, we have the main action class. Now we may define various actions (e.g. particle generation) and then insert the back into the <code>Build</code> method, that will be triggered for each event, in the first run, in the last run ...</p>"},{"location":"szd2/geant/geant4.html#define-primary-particle-generation","title":"Define primary particle generation","text":"<p>For generation of primary particles, we will make use of </p> <ul> <li><code>G4VUserPrimaryGeneratorAction</code> class to specify the particle and trigger the generation during the run,</li> <li><code>G4ParticleGun</code> class to generate the particles.</li> </ul> <p>In this example, we define 100 MeV electrons with momentum in the forward (z) direction only.</p> C++Python <p>We need to create two additional files: <code>include/particleGenerator.hh</code> and <code>src/particleGenerator.cc</code>.</p> include/particleGenerator.hh<pre><code>#ifndef PARTICLEGENERATOR_HH\n#define ARTICLEGENERATOR_HH\n\n#include &lt;G4VUserPrimaryGeneratorAction.hh&gt;\n#include &lt;G4ParticleGun.hh&gt;\n\nclass particleGenerator : public G4VUserPrimaryGeneratorAction {\npublic:\n    particleGenerator();\n    ~particleGenerator();\n\n    // all setup will be defined in this method\n    virtual void GeneratePrimaries(G4Event *anEvent);\nprivate:\n    G4ParticleGun *fParticleGun; // this is the particle gun itself\n};\n\n\n#endif //PARTICLEGENERATOR_HH\n</code></pre> src/particleGenerator.cc<pre><code>#include \"../include/particleGenerator.hh\"\n#include &lt;G4ParticleTable.hh&gt;\n#include &lt;G4SystemOfUnits.hh&gt;\n\n// CONSTRUCTOR\nparticleGenerator::particleGenerator(){\n    // we create the particle generator itself\n    fParticleGun = new G4ParticleGun(1); // argument is the number of primary vertices, see the comment box bellow\n\n    // select electron\n    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();\n    G4String particleName;\n    G4ParticleDefinition* particle\n            = particleTable-&gt;FindParticle(particleName=\"e-\"); // (1)!\n\n    // we tell the particle gun to create an electron ...\n    fParticleGun-&gt;SetParticleDefinition(particle);\n    // ... in the forward (z) direction ...\n    fParticleGun-&gt;SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.)); // x, y, z\n    // ... with energy of 100 MeV ...\n    fParticleGun-&gt;SetParticleEnergy(100. * MeV);\n    // ... and the position of the source\n    fParticleGun-&gt;SetParticlePosition(G4ThreeVector(0, 0, -0.5 * cm)); // x, y, z\n\n}\n\n// DESTRUCTOR\nparticleGenerator::~particleGenerator(){\n    delete fParticleGun;\n}\n\n// this is the method that generates the particles for each event\nvoid particleGenerator::GeneratePrimaries(G4Event *anEvent) {\n    fParticleGun-&gt;GeneratePrimaryVertex(anEvent);\n}\n</code></pre> <ol> <li>Most particles are already predefined, so we use the predefined electron.</li> </ol> <pre><code>from geant4_pybind import *\n\nclass particleGenerator(G4VUserPrimaryGeneratorAction):\n    def __init__(self, electronEnergy):\n        super().__init__()\n\n        # we create the particle generator itself\n        self.fParticleGun = G4ParticleGun(1) # argument is the number of primary vertices, see the comment box bellow\n\n        # we tell the particle gun to create an electron ...\n        self.fParticleGun.SetParticleDefinition(G4Electron.Definition())\n        # ... in the forward (z) direction ...\n        self.fParticleGun.SetParticleMomentumDirection(G4ThreeVector(0, 0, 1)) # x, y, z\n        # ... with energy of 100 MeV ...\n        self.fParticleGun.SetParticleEnergy(100 * MeVs)\n        # ... and the position of the source\n        self.fParticleGun.SetParticlePosition(G4ThreeVector(0, 0, -0.5 * cm)) # x, y, z \n\n    def GeneratePrimaries(self, event):\n        self.fParticleGun.GeneratePrimaryVertex(event)\n</code></pre> <p>Info</p> <p>When creating the particle gun using the <code>G4ParticleGun</code> class, we used <code>1</code> as the argument: this is the number of primary vertices. However, typically, we want to simulate more than one particle to gain some statistics.</p> <p>This is because the convention in Geant4 is to generate one particle per event and have the number of events corresponding to the total number of particles we want to simulate. </p> <p>Also note, that there are no collective effects implemented into Geant4: therefore, multiple primary particles generated in the event do not affect each other. </p> <p>Info</p> <p>Note that we are using the standard units (cm, MeV). This is thanks to the <code>#include &lt;G4SystemOfUnits.hh&gt;</code> in <code>C++</code> and  <code>from geant4_pybind import *</code> in <code>Python</code>.</p> <p>Finally, we need to add this action to the main action class created in Action definition.</p> C++Python src/action.cc<pre><code>#include \"../include/action.hh\"\n#include \"../include/particleGenerator.hh\"\n\nActionInitialization::ActionInitialization() = default;\n\nActionInitialization::~ActionInitialization() = default;\n\nvoid ActionInitialization::Build() const {\n    // particle generation action\n    auto generator = new particleGenerator();\n    SetUserAction(generator);\n}\n</code></pre> mainFile.py or action.py<pre><code>class ActionInitialization(G4VUserActionInitialization):\n    def Build(self):\n        generator = particleGenerator() # (1)!\n        self.SetUserAction(generator)\n</code></pre> <ol> <li>Provided that the definition of <code>particleGenerator</code> class is in the same file or is properly imported (it is the class that we created at the beginning of Define primary particle section).</li> </ol>"},{"location":"szd2/geant/geant4.html#define-particle-detection","title":"Define particle detection","text":""},{"location":"szd2/geant/geant4.html#running-the-simulation","title":"Running the simulation","text":"C++Python <p>The environment with Geant4 must be correctly intialized.</p> <p>Due to the multiple files we have, we will use CMake for compilation, so the top directory must contain the <code>CMakeLists.txt</code> file. This is already set up in the provided examples.</p> Sample <code>CMakeLists.txt</code> <p>In the provided examples, the <code>CMakeLists.txt</code> is already set up. Nevertheless, when working with the file structure</p> <pre><code>mainFile.cc\nCMakeLists.txt\ninclude/\n    construction.hh\n    physicsList.hh\n    action.hh\nsrc/\n    construction.cc\n    physicsList.cc\n    action.cc\n</code></pre> <p>The <code>CMakeLists.txt</code> contains:</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 2.6 FATAL_ERROR)\n\nproject(example)\n\nfind_package(Geant4 REQUIRED ui_all vis_all)\n\ninclude(${Geant4_USE_FILE})\n\nfile(GLOB sources ${PROJECT_SOURCE_DIR}/src/*.cc)\nfile(GLOB headers ${PROJECT_SOURCE_DIR}/include/*.hh)\n\nadd_executable(mainFile mainFile.cc ${sources} ${headers}\n        include/construction.hh\n        src/physicsList.cc\n        src/action.cc\n        include/construction.hh\n        include/physicsList.hh\n        include/action.hh)\ntarget_link_libraries(mainFile ${Geant4_LIBRARIES})\n\nadd_custom_target(mainFileCC DEPENDS mainFile)\n</code></pre> <p>During the first build, one must run (from the top directory including <code>CMakeLists.txt</code>)</p> <pre><code>mkdir build\ncd build\ncmake ..\n</code></pre> <p>This will setup the build directory. Now we can build and run the program inside the build directory</p> <pre><code>make\n./mainFile\n</code></pre> <p>After editing the code, we have to rebuild the project using the <code>make</code> command.</p> <p>Python environment with Geant4 must be correctly initialized first. After that, we write into the terminal</p> <pre><code>python mainFile.py\n</code></pre>"},{"location":"tags.html","title":"Homework","text":""},{"location":"tags.html#szd1-homework","title":"SZD1 Homework","text":"<ul> <li>The three door problem</li> </ul>"}]}